2025-08-18 13:21:39.865 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:39.865 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=getsourcecode 
2025-08-18 13:21:39.866 INFO: [hardhat.handler.js] >> handleGetSourceCode 
2025-08-18 13:21:39.866 INFO: [contract.model.js] >> getContractByAddress 
2025-08-18 13:21:39.932 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-18 13:21:39.933 INFO: [hardhat.handler.js] >> formatToEtherscanResponse 
2025-08-18 13:21:40.089 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:40.090 INFO: [API] Menerima permintaan Hardhat: method=POST, module=logs, action=getLogs 
2025-08-18 13:21:40.090 INFO: [hardhat.handler.js] >> handleGetLogs 
2025-08-18 13:21:40.271 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:40.271 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-08-18 13:21:40.272 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-08-18 13:21:40.276 INFO: â„¹ï¸ [verification.service.js] >> verify null
2025-08-18 13:21:40.277 INFO: â„¹ï¸ [verification.validator.js] >> validateAndDefault null
2025-08-18 13:21:40.277 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-08-18 13:21:40.278 INFO: â„¹ï¸ Parameter validasi berhasil {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  fullContractName: '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol:TransparentUpgradeableProxy',
  compilerVersion: 'v0.8.29+commit.ab55807c',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '00000000000000000000...',
  sourceCodeLength: 42297,
  evmVersion: 'default'
}
2025-08-18 13:21:40.279 INFO: â„¹ï¸ [verification.bytecode.js] >> getDeployedBytecode null
2025-08-18 13:21:40.280 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-18 13:21:40.280 INFO: â„¹ï¸ Connecting to RPC: http://127.0.0.1:8545 null
2025-08-18 13:21:40.506 INFO: âœ… Deployed bytecode berhasil diambil (2336 karakter) 
2025-08-18 13:21:40.506 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-08-18 13:21:40.507 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:40.508 INFO: â„¹ï¸ [verification.compiler.js] >> prepareSolcInput null
2025-08-18 13:21:40.509 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-08-18 13:21:40.509 INFO: â„¹ï¸ Mode deteksi: Standard JSON Input null
2025-08-18 13:21:40.510 INFO: âœ… Input mode: Standard JSON Input 
2025-08-18 13:21:40.511 INFO: â„¹ï¸ Solc input summary {
  language: 'Solidity',
  sourcesCount: 14,
  sourcesList: '@openzeppelin/contracts/access/Ownable.sol, @openzeppelin/contracts/interfaces/IERC1967.sol, @openzeppelin/contracts/proxy/beacon/BeaconProxy.sol, @openzeppelin/contracts/proxy/beacon/IBeacon.sol, @openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol, @openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol, @openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol, @openzeppelin/contracts/proxy/Proxy.sol, @openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol, @openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol, @openzeppelin/contracts/utils/Address.sol, @openzeppelin/contracts/utils/Context.sol, @openzeppelin/contracts/utils/Errors.sol, @openzeppelin/contracts/utils/StorageSlot.sol',
  mainContract: 'TransparentUpgradeableProxy',
  contractPath: '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol',
  optimizer_enabled: true,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-08-18 13:21:40.512 INFO: â„¹ï¸ [verification.compiler.js] >> compile null
2025-08-18 13:21:40.513 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-08-18 13:21:41.711 INFO: â„¹ï¸ Kompilasi selesai dalam 1197ms null
2025-08-18 13:21:41.719 INFO: âœ… Kompilasi berhasil tanpa error 
2025-08-18 13:21:41.719 INFO: â„¹ï¸ [verification.compiler.js] >> extractContractArtifact null
2025-08-18 13:21:41.719 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-08-18 13:21:41.719 INFO: âœ… Contract artifact berhasil diekstrak 
2025-08-18 13:21:41.720 INFO: â„¹ï¸ [verification.bytecode.js] >> compareBytecodes null
2025-08-18 13:21:41.720 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-08-18 13:21:41.720 INFO: â„¹ï¸ Menganalisis bytecode yang di-deploy... null
2025-08-18 13:21:41.720 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-08-18 13:21:41.720 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:41.721 INFO: â„¹ï¸ Menganalisis bytecode hasil kompilasi... null
2025-08-18 13:21:41.721 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-08-18 13:21:41.721 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:41.723 INFO: [bytecode.utils.js] >> compareBytecode 
2025-08-18 13:21:41.723 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:41.723 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:41.723 INFO: [bytecode.utils.js] >> logDifferences 
2025-08-18 13:21:41.723 ERROR: âŒ âŒâŒâŒ Bytecode TIDAK COCOK - Verifikasi gagal âŒâŒâŒ ''
2025-08-18 13:21:41.751 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:41.752 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifyproxycontract 
2025-08-18 13:21:41.752 INFO: [hardhat.handler.js] >> handleVerifyProxyContract 
2025-08-18 13:21:41.752 INFO: [API] Menerima permintaan verifikasi proxy contract: {
  module: 'contract',
  action: 'verifyproxycontract',
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  expectedimplementation: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  apikey: 'any-string-will-do',
  chainid: ''
}
2025-08-18 13:21:41.752 INFO: [contract.service.js] >> linkProxyContract 
2025-08-18 13:21:41.752 INFO: [API Service][linkProxyContract] ðŸ”— Menautkan proxy 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF ke implementasi 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-18 13:21:41.752 INFO: [API Service][linkProxyContract] ðŸ“ž Memanggil verifyProxy... 
2025-08-18 13:21:41.753 INFO: [contract.service.js] >> verifyProxy 
2025-08-18 13:21:41.753 INFO: [API Service][verifyProxy] ðŸ•µï¸ Memulai verifikasi proxy (versi Lanjutan) untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF -> 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-18 13:21:41.753 INFO: [API Service][verifyProxy] [1/4] ðŸ” Mengecek status verifikasi untuk alamat implementasi: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-18 13:21:41.753 INFO: [contract.model.js] >> getContractByAddress 
2025-08-18 13:21:41.757 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-18 13:21:41.758 INFO: [API Service][verifyProxy] âœ… OK: Kontrak implementasi terverifikasi. 
2025-08-18 13:21:41.758 INFO: [API Service][verifyProxy] [2/4] ðŸ”¬ Menjalankan deteksi proxy tingkat lanjut untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF... 
2025-08-18 13:21:42.758 INFO: [API Service][verifyProxy]   - Hasil Deteksi: {
  isProxy: true,
  proxyType: 'eip1967',
  implementation: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  beacon: null,
  confidence: 'high',
  details: [
    'EIP-1967 implementation slot detected',
    'EIP-1967 admin slot detected',
    'Bytecode confirms: Generic Delegatecall Pattern',
    'Implementation address validated'
  ],
  warnings: [],
  found: true
}
2025-08-18 13:21:42.764 INFO: [API Service][verifyProxy] [3/4] ðŸ”„ Membandingkan alamat implementasi... 
2025-08-18 13:21:42.765 INFO:    - Terdeteksi: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-18 13:21:42.765 INFO:    - Diberikan:  0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-18 13:21:42.767 INFO: [API Service][verifyProxy] âœ… OK: Alamat implementasi cocok. 
2025-08-18 13:21:42.767 INFO: [API Service][verifyProxy] [4/4] ðŸ’¾ Menyimpan detail proxy yang terdeteksi ke database... 
2025-08-18 13:21:42.767 INFO: [contract.model.js] >> setProxyDetails 
2025-08-18 13:21:42.768 INFO: [DB Model][setProxyDetails] Executing UPDATE on 'contracts' table for 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF. {
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  proxyType: 'eip1967',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7'
}
2025-08-18 13:21:42.777 INFO: [DB Model] Berhasil memperbarui detail proxy untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF. 
2025-08-18 13:21:42.781 INFO: [API Service] Successfully verified and saved proxy relationship. 
2025-08-18 13:21:42.782 INFO: [API Service][verifyProxy] ðŸ”„ Mengambil data kontrak yang sudah diperbarui untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-18 13:21:42.782 INFO: [contract.service.js] >> getContractByAddress 
2025-08-18 13:21:42.785 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-18 13:21:42.786 INFO: [contract.model.js] >> getContractByAddress 
2025-08-18 13:21:42.800 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-18 13:21:42.803 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-18 13:21:42.809 INFO: [API Service] Mapped data for GraphQL: {
  address: undefined,
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-18 13:21:42.816 INFO: [API Service][verifyProxy] ðŸŽ‰ Verifikasi proxy BERHASIL. 
2025-08-18 13:21:42.816 INFO: [API Service][linkProxyContract] âœ… Hasil dari verifyProxy: Proxy successfully verified and linked with detailed detection. {
  success: true,
  message: 'Proxy successfully verified and linked with detailed detection.',
  contract: {
    address: undefined,
    creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
    creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
    isVerified: true,
    sourceFiles: [
      {
        filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
        sourceCode: '// SPDX-License-Identifier: MIT\n' +
          '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
          '\n' +
          'pragma solidity ^0.8.20;\n' +
          '\n' +
          '/**\n' +
          ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
          " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
          ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
          ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
          ' *\n' +
          ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
          ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
          ' * case an upgrade adds a module that needs to be initialized.\n' +
          ' *\n' +
          ' * For example:\n' +
          ' *\n' +
          ' * [.hljs-theme-light.nopadding]\n' +
          ' * ```solidity\n' +
          ' * contract MyToken is ERC20Upgradeable {\n' +
          ' *     function initialize() initializer public {\n' +
          ' *         __ERC20_init("MyToken", "MTK");\n' +
          ' *     }\n' +
          ' * }\n' +
          ' *\n' +
          ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
          ' *     function initializeV2() reinitializer(2) public {\n' +
          ' *         __ERC20Permit_init("MyToken");\n' +
          ' *     }\n' +
          ' * }\n' +
          ' * ```\n' +
          ' *\n' +
          ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
          ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
          ' *\n' +
          ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
          ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
          ' *\n' +
          ' * [CAUTION]\n' +
          ' * ====\n' +
          ' * Avoid leaving a contract uninitialized.\n' +
          ' *\n' +
          ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
          ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
          ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
          ' *\n' +
          ' * [.hljs-theme-light.nopadding]\n' +
          ' * ```\n' +
          ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
          ' * constructor() {\n' +
          ' *     _disableInitializers();\n' +
          ' * }\n' +
          ' * ```\n' +
          ' * ====\n' +
          ' */\n' +
          'abstract contract Initializable {\n' +
          '    /**\n' +
          '     * @dev Storage of the initializable contract.\n' +
          '     *\n' +
          "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
          '     * when using with upgradeable contracts.\n' +
          '     *\n' +
          '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
          '     */\n' +
          '    struct InitializableStorage {\n' +
          '        /**\n' +
          '         * @dev Indicates that the contract has been initialized.\n' +
          '         */\n' +
          '        uint64 _initialized;\n' +
          '        /**\n' +
          '         * @dev Indicates that the contract is in the process of being initialized.\n' +
          '         */\n' +
          '        bool _initializing;\n' +
          '    }\n' +
          '\n' +
          '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
          '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
          '\n' +
          '    /**\n' +
          '     * @dev The contract is already initialized.\n' +
          '     */\n' +
          '    error InvalidInitialization();\n' +
          '\n' +
          '    /**\n' +
          '     * @dev The contract is not initializing.\n' +
          '     */\n' +
          '    error NotInitializing();\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
          '     */\n' +
          '    event Initialized(uint64 version);\n' +
          '\n' +
          '    /**\n' +
          '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
          '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
          '     *\n' +
          '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
          '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
          '     * production.\n' +
          '     *\n' +
          '     * Emits an {Initialized} event.\n' +
          '     */\n' +
          '    modifier initializer() {\n' +
          '        // solhint-disable-next-line var-name-mixedcase\n' +
          '        InitializableStorage storage $ = _getInitializableStorage();\n' +
          '\n' +
          '        // Cache values to avoid duplicated sloads\n' +
          '        bool isTopLevelCall = !$._initializing;\n' +
          '        uint64 initialized = $._initialized;\n' +
          '\n' +
          '        // Allowed calls:\n' +
          '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
          '        //                 initialized\n' +
          '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
          '        //                 current contract is just being deployed\n' +
          '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
          '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
          '\n' +
          '        if (!initialSetup && !construction) {\n' +
          '            revert InvalidInitialization();\n' +
          '        }\n' +
          '        $._initialized = 1;\n' +
          '        if (isTopLevelCall) {\n' +
          '            $._initializing = true;\n' +
          '        }\n' +
          '        _;\n' +
          '        if (isTopLevelCall) {\n' +
          '            $._initializing = false;\n' +
          '            emit Initialized(1);\n' +
          '        }\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
          "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
          '     * used to initialize parent contracts.\n' +
          '     *\n' +
          '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
          '     * are added through upgrades and that require initialization.\n' +
          '     *\n' +
          '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
          '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
          '     *\n' +
          '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
          '     * a contract, executing them in the right order is up to the developer or operator.\n' +
          '     *\n' +
          '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
          '     *\n' +
          '     * Emits an {Initialized} event.\n' +
          '     */\n' +
          '    modifier reinitializer(uint64 version) {\n' +
          '        // solhint-disable-next-line var-name-mixedcase\n' +
          '        InitializableStorage storage $ = _getInitializableStorage();\n' +
          '\n' +
          '        if ($._initializing || $._initialized >= version) {\n' +
          '            revert InvalidInitialization();\n' +
          '        }\n' +
          '        $._initialized = version;\n' +
          '        $._initializing = true;\n' +
          '        _;\n' +
          '        $._initializing = false;\n' +
          '        emit Initialized(version);\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
          '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
          '     */\n' +
          '    modifier onlyInitializing() {\n' +
          '        _checkInitializing();\n' +
          '        _;\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
          '     */\n' +
          '    function _checkInitializing() internal view virtual {\n' +
          '        if (!_isInitializing()) {\n' +
          '            revert NotInitializing();\n' +
          '        }\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
          '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
          '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
          '     * through proxies.\n' +
          '     *\n' +
          '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
          '     */\n' +
          '    function _disableInitializers() internal virtual {\n' +
          '        // solhint-disable-next-line var-name-mixedcase\n' +
          '        InitializableStorage storage $ = _getInitializableStorage();\n' +
          '\n' +
          '        if ($._initializing) {\n' +
          '            revert InvalidInitialization();\n' +
          '        }\n' +
          '        if ($._initialized != type(uint64).max) {\n' +
          '            $._initialized = type(uint64).max;\n' +
          '            emit Initialized(type(uint64).max);\n' +
          '        }\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
          '     */\n' +
          '    function _getInitializedVersion() internal view returns (uint64) {\n' +
          '        return _getInitializableStorage()._initialized;\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
          '     */\n' +
          '    function _isInitializing() internal view returns (bool) {\n' +
          '        return _getInitializableStorage()._initializing;\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
          '     *\n' +
          '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
          '     */\n' +
          '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
          '        return INITIALIZABLE_STORAGE;\n' +
          '    }\n' +
          '\n' +
          '    /**\n' +
          '     * @dev Returns a pointer to the storage namespace.\n' +
          '     */\n' +
          '    // solhint-disable-next-line var-name-mixedcase\n' +
          '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
          '        bytes32 slot = _initializableStorageSlot();\n' +
          '        assembly {\n' +
          '            $.slot := slot\n' +
          '        }\n' +
          '    }\n' +
          '}\n'
      },
      {
        filePath: 'contracts/TokenSafeV2.sol',
        sourceCode: '// contracts/TokenSafeV2.sol\n' +
          '\n' +
          '// SPDX-License-Identifier: MIT\n' +
          'pragma solidity ^0.8.20;\n' +
          '\n' +
          'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
          '\n' +
          '// Interface IGoldToken tetap sama\n' +
          'interface IGoldToken {\n' +
          '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
          '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
          '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
          '}\n' +
          '\n' +
          'contract TokenSafeV2 is Initializable {\n' +
          '    IGoldToken public goldToken;\n' +
          '    address public owner;\n' +
          '\n' +
          '    mapping(address => uint256) public lockedBalances;\n' +
          '\n' +
          '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
          '    constructor() {\n' +
          '        _disableInitializers();\n' +
          '    }\n' +
          '\n' +
          '    // Initializer tidak perlu diubah\n' +
          '    function initialize(address _tokenAddress) public initializer {\n' +
          '        goldToken = IGoldToken(_tokenAddress);\n' +
          '        owner = msg.sender;\n' +
          '    }\n' +
          '\n' +
          '    // Fungsi lockTokens tetap sama\n' +
          '    function lockTokens(uint256 _amount) public {\n' +
          '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
          '        lockedBalances[msg.sender] += _amount;\n' +
          '    }\n' +
          '\n' +
          '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
          '    function unlockTokens(uint256 _amount) public {\n' +
          '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
          '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
          '\n' +
          '        // 2. Kurangi catatan saldo yang terkunci\n' +
          '        lockedBalances[msg.sender] -= _amount;\n' +
          '\n' +
          '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
          '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
          '    }\n' +
          '}'
      }
    ],
    contractName: 'TokenSafeV2',
    compilerVersion: 'v0.8.28+commit.7893614a',
    abi: [
      {
        type: 'constructor',
        inputs: [],
        stateMutability: 'nonpayable'
      },
      { name: 'InvalidInitialization', type: 'error', inputs: [] },
      { name: 'NotInitializing', type: 'error', inputs: [] },
      {
        name: 'Initialized',
        type: 'event',
        inputs: [ [Object] ],
        anonymous: false
      },
      {
        name: 'goldToken',
        type: 'function',
        inputs: [],
        outputs: [ [Object] ],
        stateMutability: 'view'
      },
      {
        name: 'initialize',
        type: 'function',
        inputs: [ [Object] ],
        outputs: [],
        stateMutability: 'nonpayable'
      },
      {
        name: 'lockTokens',
        type: 'function',
        inputs: [ [Object] ],
        outputs: [],
        stateMutability: 'nonpayable'
      },
      {
        name: 'lockedBalances',
        type: 'function',
        inputs: [ [Object] ],
        outputs: [ [Object] ],
        stateMutability: 'view'
      },
      {
        name: 'owner',
        type: 'function',
        inputs: [],
        outputs: [ [Object] ],
        stateMutability: 'view'
      },
      {
        name: 'unlockTokens',
        type: 'function',
        inputs: [ [Object] ],
        outputs: [],
        stateMutability: 'nonpayable'
      }
    ],
    optimizationUsed: false,
    runs: 200,
    constructorArguments: null,
    evmVersion: 'paris',
    isProxy: true,
    proxyType: 'eip1967',
    implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
    adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
    blockNumber: '19'
  }
}
2025-08-18 13:21:42.852 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:42.852 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=checkproxyverification 
2025-08-18 13:21:42.853 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-08-18 13:21:42.853 INFO: [contract.model.js] >> getContractByAddress 
2025-08-18 13:21:42.857 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-18 13:21:42.936 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:42.936 INFO: [API] Menerima permintaan Hardhat: method=POST, module=logs, action=getLogs 
2025-08-18 13:21:42.939 INFO: [hardhat.handler.js] >> handleGetLogs 
2025-08-18 13:21:43.299 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:43.300 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-08-18 13:21:43.300 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-08-18 13:21:43.300 INFO: â„¹ï¸ [verification.service.js] >> verify null
2025-08-18 13:21:43.301 INFO: â„¹ï¸ [verification.validator.js] >> validateAndDefault null
2025-08-18 13:21:43.301 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-08-18 13:21:43.302 INFO: â„¹ï¸ Parameter validasi berhasil {
  address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  fullContractName: '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol:ProxyAdmin',
  compilerVersion: 'v0.8.29+commit.ab55807c',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '00000000000000000000...',
  sourceCodeLength: 42297,
  evmVersion: 'default'
}
2025-08-18 13:21:43.306 INFO: â„¹ï¸ [verification.bytecode.js] >> getDeployedBytecode null
2025-08-18 13:21:43.306 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0xB9462EF3441346dBc6E49236Edbb0dF207db09B7 
2025-08-18 13:21:43.307 INFO: â„¹ï¸ Connecting to RPC: http://127.0.0.1:8545 null
2025-08-18 13:21:43.381 INFO: âœ… Deployed bytecode berhasil diambil (2144 karakter) 
2025-08-18 13:21:43.382 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-08-18 13:21:43.383 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:43.384 INFO: â„¹ï¸ [verification.compiler.js] >> prepareSolcInput null
2025-08-18 13:21:43.384 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-08-18 13:21:43.385 INFO: â„¹ï¸ Mode deteksi: Standard JSON Input null
2025-08-18 13:21:43.386 INFO: âœ… Input mode: Standard JSON Input 
2025-08-18 13:21:43.387 INFO: â„¹ï¸ Solc input summary {
  language: 'Solidity',
  sourcesCount: 14,
  sourcesList: '@openzeppelin/contracts/access/Ownable.sol, @openzeppelin/contracts/interfaces/IERC1967.sol, @openzeppelin/contracts/proxy/beacon/BeaconProxy.sol, @openzeppelin/contracts/proxy/beacon/IBeacon.sol, @openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol, @openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol, @openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol, @openzeppelin/contracts/proxy/Proxy.sol, @openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol, @openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol, @openzeppelin/contracts/utils/Address.sol, @openzeppelin/contracts/utils/Context.sol, @openzeppelin/contracts/utils/Errors.sol, @openzeppelin/contracts/utils/StorageSlot.sol',
  mainContract: 'ProxyAdmin',
  contractPath: '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol',
  optimizer_enabled: true,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-08-18 13:21:43.392 INFO: â„¹ï¸ [verification.compiler.js] >> compile null
2025-08-18 13:21:43.393 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-08-18 13:21:44.948 INFO: â„¹ï¸ Kompilasi selesai dalam 1554ms null
2025-08-18 13:21:44.954 INFO: âœ… Kompilasi berhasil tanpa error 
2025-08-18 13:21:44.955 INFO: â„¹ï¸ [verification.compiler.js] >> extractContractArtifact null
2025-08-18 13:21:44.955 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-08-18 13:21:44.955 INFO: âœ… Contract artifact berhasil diekstrak 
2025-08-18 13:21:44.955 INFO: â„¹ï¸ [verification.bytecode.js] >> compareBytecodes null
2025-08-18 13:21:44.956 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-08-18 13:21:44.956 INFO: â„¹ï¸ Menganalisis bytecode yang di-deploy... null
2025-08-18 13:21:44.956 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-08-18 13:21:44.956 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:44.956 INFO: â„¹ï¸ Menganalisis bytecode hasil kompilasi... null
2025-08-18 13:21:44.956 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-08-18 13:21:44.957 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:44.957 INFO: [bytecode.utils.js] >> compareBytecode 
2025-08-18 13:21:44.957 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:44.957 INFO: [bytecode.utils.js] >> stripMetadata 
2025-08-18 13:21:44.957 INFO: âœ… âœ…âœ…âœ… Bytecode COCOK! Kontrak terverifikasi. âœ…âœ…âœ… 
2025-08-18 13:21:44.958 INFO: â„¹ï¸ [verification.db.js] >> saveVerificationResult null
2025-08-18 13:21:44.958 INFO: [6/6] Menyimpan kontrak terverifikasi ke database 
2025-08-18 13:21:44.958 INFO: â„¹ï¸ Preparing contract data for database {
  address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  contractName: 'ProxyAdmin',
  compilerVersion: 'v0.8.29+commit.ab55807c',
  abiLength: 9,
  optimizationUsed: true,
  runs: 200,
  constructorArgumentsLength: 64,
  evmVersion: 'paris',
  sourceFilesCount: 14
}
2025-08-18 13:21:44.959 INFO: [contract.model.js] >> saveVerifiedContract 
2025-08-18 13:21:44.991 INFO: âœ… Kontrak berhasil diverifikasi dan disimpan! 
2025-08-18 13:21:44.992 INFO: âœ… Total waktu verifikasi: 1691ms 
2025-08-18 13:21:44.996 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-08-18 13:21:44.996 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=checkverifystatus 
2025-08-18 13:21:44.996 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-08-18 13:21:44.996 INFO: [contract.model.js] >> getContractByAddress 
2025-08-18 13:21:45.002 INFO: [DB Model] Data final yang digabungkan untuk 0xB9462EF3441346dBc6E49236Edbb0dF207db09B7: {
  query_address: '0xb9462ef3441346dbc6e49236edbb0df207db09b7',
  contract_address: null,
  creator_address: null,
  creation_tx_hash: null,
  block_number: null,
  is_proxy: false,
  proxy_type: null,
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  is_verified: true,
  contract_name: 'ProxyAdmin',
  compiler_version: 'v0.8.29+commit.ab55807c',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: '000000000000000000000000627306090abab3a6e1400e9345bc60c78a8bef57',
  evm_version: 'paris',
  verified_at: 2025-08-18T06:21:44.960Z,
  sourceFiles: '...'
}
2025-08-18 13:38:04.669 INFO: [verification.utils.js] loaded 
