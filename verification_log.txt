2025-08-23 14:28:42.385 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-23 14:28:42.385 INFO: [contract.service.js] >> getContracts 
2025-08-23 14:28:42.385 INFO: [API Service] Fetching all contracts 
2025-08-23 14:28:42.385 INFO: [contract.model.js] >> getContracts 
2025-08-23 14:28:44.100 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 14:28:44.100 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 14:28:44.100 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 14:28:44.100 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 14:28:44.105 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 14:28:44.106 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 14:28:44.108 INFO: [API Service] Mapped data for GraphQL: {
  address: undefined,
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:04:29.381 INFO: [verification.utils.js] loaded 
2025-08-23 18:07:28.864 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:28.864 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:28.865 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:07:28.865 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:28.904 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:28.906 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:28.916 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:07:29.683 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:29.684 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:29.684 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:07:29.684 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:29.687 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:29.688 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:29.692 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:07:40.080 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:40.080 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:40.081 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-23 18:07:40.081 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:40.098 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:40.099 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:40.100 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-23 18:07:43.102 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-23 18:07:43.102 INFO: [contract.service.js] >> getContracts 
2025-08-23 18:07:43.103 INFO: [API Service] Fetching all contracts 
2025-08-23 18:07:43.103 INFO: [contract.model.js] >> getContracts 
2025-08-23 18:07:46.335 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:46.335 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:46.336 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:07:46.336 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:46.338 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:46.339 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:46.341 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:07:55.007 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:55.007 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:55.007 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-23 18:07:55.008 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:55.010 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:55.011 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:55.012 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-23 18:08:23.652 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-23 18:08:23.652 INFO: [contract.service.js] >> getContracts 
2025-08-23 18:08:23.653 INFO: [API Service] Fetching all contracts 
2025-08-23 18:08:23.653 INFO: [contract.model.js] >> getContracts 
2025-08-23 18:08:25.831 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:08:25.831 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:08:25.831 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:08:25.831 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:08:25.837 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:08:25.838 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:08:25.840 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-24 14:11:04.245 INFO: [verification.utils.js] loaded 
2025-08-24 14:11:08.365 INFO: [verification.utils.js] loaded 
2025-08-24 14:12:04.634 INFO: [verification.utils.js] loaded 
2025-08-24 14:12:56.018 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-24 14:12:56.019 INFO: [contract.service.js] >> getContracts 
2025-08-24 14:12:56.019 INFO: [API Service] Fetching all contracts 
2025-08-24 14:12:56.019 INFO: [contract.model.js] >> getContracts 
2025-08-24 14:13:00.479 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:13:00.480 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:13:00.480 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-24 14:13:00.481 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:13:00.489 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:13:00.490 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:13:00.494 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-24 14:13:47.312 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:13:47.312 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:13:47.312 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-24 14:13:47.312 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:13:47.334 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:13:47.334 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:13:47.336 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-24 14:14:33.319 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:14:33.320 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:14:33.320 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-24 14:14:33.320 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:14:33.339 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:14:33.340 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:14:33.342 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-24 14:14:40.460 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:14:40.460 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:14:40.460 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-24 14:14:40.460 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:14:40.463 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:14:40.464 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:14:40.466 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-24 14:14:42.923 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-24 14:14:42.924 INFO: [contract.service.js] >> getContracts 
2025-08-24 14:14:42.924 INFO: [API Service] Fetching all contracts 
2025-08-24 14:14:42.924 INFO: [contract.model.js] >> getContracts 
2025-08-24 14:15:37.587 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-24 14:15:37.587 INFO: [contract.service.js] >> getContracts 
2025-08-24 14:15:37.587 INFO: [API Service] Fetching all contracts 
2025-08-24 14:15:37.587 INFO: [contract.model.js] >> getContracts 
2025-08-24 14:15:40.375 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:15:40.375 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:15:40.375 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-24 14:15:40.375 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:15:40.380 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:15:40.380 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:15:40.382 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-09-26 12:26:35.898 INFO: [verification.utils.js] loaded 
2025-09-26 12:27:07.767 INFO: [contract.resolver.js] >> Query.contracts 
2025-09-26 12:27:07.768 INFO: [contract.service.js] >> getContracts 
2025-09-26 12:27:07.768 INFO: [API Service] Fetching all contracts 
2025-09-26 12:27:07.768 INFO: [contract.model.js] >> getContracts 
