2025-08-23 14:28:42.385 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-23 14:28:42.385 INFO: [contract.service.js] >> getContracts 
2025-08-23 14:28:42.385 INFO: [API Service] Fetching all contracts 
2025-08-23 14:28:42.385 INFO: [contract.model.js] >> getContracts 
2025-08-23 14:28:44.100 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 14:28:44.100 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 14:28:44.100 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 14:28:44.100 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 14:28:44.105 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 14:28:44.106 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 14:28:44.108 INFO: [API Service] Mapped data for GraphQL: {
  address: undefined,
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:04:29.381 INFO: [verification.utils.js] loaded 
2025-08-23 18:07:28.864 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:28.864 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:28.865 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:07:28.865 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:28.904 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:28.906 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:28.916 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:07:29.683 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:29.684 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:29.684 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:07:29.684 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:29.687 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:29.688 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:29.692 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:07:40.080 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:40.080 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:40.081 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-23 18:07:40.081 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:40.098 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:40.099 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:40.100 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-23 18:07:43.102 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-23 18:07:43.102 INFO: [contract.service.js] >> getContracts 
2025-08-23 18:07:43.103 INFO: [API Service] Fetching all contracts 
2025-08-23 18:07:43.103 INFO: [contract.model.js] >> getContracts 
2025-08-23 18:07:46.335 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:46.335 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:46.336 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:07:46.336 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:46.338 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:46.339 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:46.341 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-23 18:07:55.007 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:07:55.007 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:07:55.007 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-23 18:07:55.008 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:07:55.010 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:07:55.011 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:07:55.012 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-23 18:08:23.652 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-23 18:08:23.652 INFO: [contract.service.js] >> getContracts 
2025-08-23 18:08:23.653 INFO: [API Service] Fetching all contracts 
2025-08-23 18:08:23.653 INFO: [contract.model.js] >> getContracts 
2025-08-23 18:08:25.831 INFO: [contract.resolver.js] >> Query.contract 
2025-08-23 18:08:25.831 INFO: [contract.service.js] >> getContractByAddress 
2025-08-23 18:08:25.831 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-23 18:08:25.831 INFO: [contract.model.js] >> getContractByAddress 
2025-08-23 18:08:25.837 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-23 18:08:25.838 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-23 18:08:25.840 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-24 14:11:04.245 INFO: [verification.utils.js] loaded 
2025-08-24 14:11:08.365 INFO: [verification.utils.js] loaded 
2025-08-24 14:12:04.634 INFO: [verification.utils.js] loaded 
2025-08-24 14:12:56.018 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-24 14:12:56.019 INFO: [contract.service.js] >> getContracts 
2025-08-24 14:12:56.019 INFO: [API Service] Fetching all contracts 
2025-08-24 14:12:56.019 INFO: [contract.model.js] >> getContracts 
2025-08-24 14:13:00.479 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:13:00.480 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:13:00.480 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-24 14:13:00.481 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:13:00.489 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:13:00.490 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:13:00.494 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-24 14:13:47.312 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:13:47.312 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:13:47.312 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-24 14:13:47.312 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:13:47.334 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:13:47.334 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:13:47.336 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-24 14:14:33.319 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:14:33.320 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:14:33.320 INFO: [API Service] Fetching contract data for address: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-08-24 14:14:33.320 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:14:33.339 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:14:33.340 INFO: [API Service] Raw data from model: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  block_number: '43',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:14:33.342 INFO: [API Service] Mapped data for GraphQL: {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x7d30453d4a04ffafd29009747b585adbca474c630c1708e07dab9d1211990930',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '43'
}
2025-08-24 14:14:40.460 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:14:40.460 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:14:40.460 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-24 14:14:40.460 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:14:40.463 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:14:40.464 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:14:40.466 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-08-24 14:14:42.923 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-24 14:14:42.924 INFO: [contract.service.js] >> getContracts 
2025-08-24 14:14:42.924 INFO: [API Service] Fetching all contracts 
2025-08-24 14:14:42.924 INFO: [contract.model.js] >> getContracts 
2025-08-24 14:15:37.587 INFO: [contract.resolver.js] >> Query.contracts 
2025-08-24 14:15:37.587 INFO: [contract.service.js] >> getContracts 
2025-08-24 14:15:37.587 INFO: [API Service] Fetching all contracts 
2025-08-24 14:15:37.587 INFO: [contract.model.js] >> getContracts 
2025-08-24 14:15:40.375 INFO: [contract.resolver.js] >> Query.contract 
2025-08-24 14:15:40.375 INFO: [contract.service.js] >> getContractByAddress 
2025-08-24 14:15:40.375 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-08-24 14:15:40.375 INFO: [contract.model.js] >> getContractByAddress 
2025-08-24 14:15:40.380 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: '...'
}
2025-08-24 14:15:40.380 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '19',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-08-16T15:38:41.197Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-08-24 14:15:40.382 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '19'
}
2025-09-26 12:26:35.898 INFO: [verification.utils.js] loaded 
2025-09-26 12:27:07.767 INFO: [contract.resolver.js] >> Query.contracts 
2025-09-26 12:27:07.768 INFO: [contract.service.js] >> getContracts 
2025-09-26 12:27:07.768 INFO: [API Service] Fetching all contracts 
2025-09-26 12:27:07.768 INFO: [contract.model.js] >> getContracts 
2025-12-17 11:40:35.992 INFO: [verification.utils.js] loaded 
2025-12-17 11:41:12.346 INFO: [contract.model.js] >> getContractByAddress 
2025-12-17 11:41:12.364 WARN: [DB Model] Kontrak 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 tidak ditemukan. 
2025-12-17 11:41:36.273 INFO: [contract.model.js] >> getContractByAddress 
2025-12-17 11:41:36.279 WARN: [DB Model] Kontrak 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 tidak ditemukan. 
2025-12-17 17:31:53.047 INFO: [verification.utils.js] loaded 
2025-12-17 17:32:07.861 INFO: [contract.model.js] >> getContractByAddress 
2025-12-17 17:32:07.899 WARN: [DB Model] Kontrak 0x627306090abaB3A6e1400e9345bC60c78a8BEf57 tidak ditemukan. 
2025-12-17 18:52:01.164 INFO: [verification.utils.js] loaded 
2025-12-24 14:00:42.903 INFO: [verification.utils.js] loaded 
2025-12-24 14:01:04.167 INFO: [contract.resolver.js] >> Query.contracts 
2025-12-24 14:01:04.167 INFO: [contract.service.js] >> getContracts 
2025-12-24 14:01:04.168 INFO: [API Service] Fetching all contracts 
2025-12-24 14:01:04.168 INFO: [contract.model.js] >> getContracts 
2025-12-24 14:10:47.050 INFO: [verification.utils.js] loaded 
2025-12-25 17:20:58.564 INFO: [verification.utils.js] loaded 
2025-12-25 17:33:32.830 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:33:32.831 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=getsourcecode 
2025-12-25 17:33:32.831 INFO: [hardhat.handler.js] >> handleGetSourceCode 
2025-12-25 17:33:32.832 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:33:32.876 INFO: [DB Model] Data final yang digabungkan untuk 0xeec918d74c746167564401103096D45BbD494B74: {
  query_address: '0xeec918d74c746167564401103096d45bbd494b74',
  contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  block_number: '79',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: null,
  is_verified: false,
  contract_name: null,
  compiler_version: null,
  abi: '...',
  optimization_used: null,
  runs: null,
  constructor_arguments: null,
  evm_version: null,
  verified_at: null,
  sourceFiles: '...'
}
2025-12-25 17:33:33.540 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:33:33.541 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-12-25 17:33:33.541 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-12-25 17:33:33.543 INFO:  [verification.service.js] >> verify null
2025-12-25 17:33:33.543 INFO:  [verification.validator.js] >> validateAndDefault null
2025-12-25 17:33:33.544 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-12-25 17:33:33.548 INFO:  Parameter validasi berhasil {
  address: '0xeec918d74c746167564401103096D45BbD494B74',
  fullContractName: 'contracts/TokenRegistry.sol:TokenRegistry',
  compilerVersion: 'v0.8.28+commit.7893614a',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '...',
  sourceCodeLength: 4737,
  evmVersion: 'default'
}
2025-12-25 17:33:33.549 INFO:  [verification.bytecode.js] >> getDeployedBytecode null
2025-12-25 17:33:33.549 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0xeec918d74c746167564401103096D45BbD494B74 
2025-12-25 17:33:33.549 INFO:  Connecting to RPC: http://100.92.191.4:8545 null
2025-12-25 17:33:33.660 INFO:  Deployed bytecode berhasil diambil (11126 karakter) 
2025-12-25 17:33:33.661 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:33:33.662 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:33.663 INFO:  [verification.compiler.js] >> prepareSolcInput null
2025-12-25 17:33:33.663 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-12-25 17:33:33.663 INFO:  Mode deteksi: Standard JSON Input null
2025-12-25 17:33:33.664 INFO:  Input mode: Standard JSON Input 
2025-12-25 17:33:33.664 INFO:  Solc input summary {
  language: 'Solidity',
  sourcesCount: 1,
  sourcesList: 'contracts/TokenRegistry.sol',
  mainContract: 'TokenRegistry',
  contractPath: 'contracts/TokenRegistry.sol',
  optimizer_enabled: false,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-12-25 17:33:33.665 INFO:  [verification.compiler.js] >> compile null
2025-12-25 17:33:33.665 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-12-25 17:33:34.057 INFO:  Kompilasi selesai dalam 391ms null
2025-12-25 17:33:34.060 INFO:  Kompilasi berhasil tanpa error 
2025-12-25 17:33:34.061 INFO:  [verification.compiler.js] >> extractContractArtifact null
2025-12-25 17:33:34.061 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-12-25 17:33:34.061 INFO:  Contract artifact berhasil diekstrak 
2025-12-25 17:33:34.061 INFO:  [verification.bytecode.js] >> compareBytecodes null
2025-12-25 17:33:34.062 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-12-25 17:33:34.062 INFO:  Menganalisis bytecode yang di-deploy... null
2025-12-25 17:33:34.062 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:33:34.063 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:34.063 INFO:  Menganalisis bytecode hasil kompilasi... null
2025-12-25 17:33:34.063 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:33:34.063 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:34.063 INFO: [bytecode.utils.js] >> compareBytecode 
2025-12-25 17:33:34.063 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:34.064 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:34.064 INFO:   Bytecode COCOK! Kontrak terverifikasi.  
2025-12-25 17:33:34.065 INFO:  [verification.db.js] >> saveVerificationResult null
2025-12-25 17:33:34.065 INFO: [6/6] Menyimpan kontrak terverifikasi ke database 
2025-12-25 17:33:34.065 INFO:  Preparing contract data for database {
  address: '0xeec918d74c746167564401103096D45BbD494B74',
  contractName: 'TokenRegistry',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abiLength: 13,
  optimizationUsed: false,
  runs: 200,
  constructorArgumentsLength: 0,
  evmVersion: 'paris',
  sourceFilesCount: 1
}
2025-12-25 17:33:34.066 INFO: [contract.model.js] >> saveVerifiedContract 
2025-12-25 17:33:34.083 INFO:  Kontrak berhasil diverifikasi dan disimpan! 
2025-12-25 17:33:34.083 INFO:  Total waktu verifikasi: 540ms 
2025-12-25 17:33:34.792 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:33:34.793 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=checkverifystatus 
2025-12-25 17:33:34.793 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-12-25 17:33:34.794 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:33:34.801 INFO: [DB Model] Data final yang digabungkan untuk 0xeec918d74c746167564401103096D45BbD494B74: {
  query_address: '0xeec918d74c746167564401103096d45bbd494b74',
  contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  block_number: '79',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  is_verified: true,
  contract_name: 'TokenRegistry',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:34.067Z,
  sourceFiles: '...'
}
2025-12-25 17:33:55.262 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:33:55.262 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=getsourcecode 
2025-12-25 17:33:55.263 INFO: [hardhat.handler.js] >> handleGetSourceCode 
2025-12-25 17:33:55.263 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:33:55.291 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x078a41be845a417f941327e07e5d8adb0fee0614f3e8ae5e34926042e682aaa3',
  block_number: '34',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: null,
  is_verified: false,
  contract_name: null,
  compiler_version: null,
  abi: '...',
  optimization_used: null,
  runs: null,
  constructor_arguments: null,
  evm_version: null,
  verified_at: null,
  sourceFiles: '...'
}
2025-12-25 17:33:56.246 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:33:56.246 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-12-25 17:33:56.247 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-12-25 17:33:56.249 INFO:  [verification.service.js] >> verify null
2025-12-25 17:33:56.249 INFO:  [verification.validator.js] >> validateAndDefault null
2025-12-25 17:33:56.249 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-12-25 17:33:56.250 INFO:  Parameter validasi berhasil {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  fullContractName: 'contracts/GoldTokenV2.sol:GoldTokenV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '...',
  sourceCodeLength: 46106,
  evmVersion: 'default'
}
2025-12-25 17:33:56.256 INFO:  [verification.bytecode.js] >> getDeployedBytecode null
2025-12-25 17:33:56.256 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4 
2025-12-25 17:33:56.256 INFO:  Connecting to RPC: http://100.92.191.4:8545 null
2025-12-25 17:33:56.339 INFO:  Deployed bytecode berhasil diambil (14502 karakter) 
2025-12-25 17:33:56.339 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:33:56.340 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:56.340 INFO:  [verification.compiler.js] >> prepareSolcInput null
2025-12-25 17:33:56.340 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-12-25 17:33:56.340 INFO:  Mode deteksi: Standard JSON Input null
2025-12-25 17:33:56.341 INFO:  Input mode: Standard JSON Input 
2025-12-25 17:33:56.341 INFO:  Solc input summary {
  language: 'Solidity',
  sourcesCount: 10,
  sourcesList: '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol, @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol, @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol, @openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol, @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol, @openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol, @openzeppelin/contracts/interfaces/draft-IERC6093.sol, @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol, @openzeppelin/contracts/token/ERC20/IERC20.sol, contracts/GoldTokenV2.sol',
  mainContract: 'GoldTokenV2',
  contractPath: 'contracts/GoldTokenV2.sol',
  optimizer_enabled: false,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-12-25 17:33:56.342 INFO:  [verification.compiler.js] >> compile null
2025-12-25 17:33:56.342 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-12-25 17:33:56.792 INFO:  Kompilasi selesai dalam 448ms null
2025-12-25 17:33:56.798 INFO:  Kompilasi berhasil tanpa error 
2025-12-25 17:33:56.798 INFO:  [verification.compiler.js] >> extractContractArtifact null
2025-12-25 17:33:56.798 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-12-25 17:33:56.799 INFO:  Contract artifact berhasil diekstrak 
2025-12-25 17:33:56.799 INFO:  [verification.bytecode.js] >> compareBytecodes null
2025-12-25 17:33:56.799 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-12-25 17:33:56.799 INFO:  Menganalisis bytecode yang di-deploy... null
2025-12-25 17:33:56.799 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:33:56.800 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:56.800 INFO:  Menganalisis bytecode hasil kompilasi... null
2025-12-25 17:33:56.800 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:33:56.800 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:56.801 INFO: [bytecode.utils.js] >> compareBytecode 
2025-12-25 17:33:56.801 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:56.801 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:33:56.805 INFO:   Bytecode COCOK! Kontrak terverifikasi.  
2025-12-25 17:33:56.805 INFO:  [verification.db.js] >> saveVerificationResult null
2025-12-25 17:33:56.806 INFO: [6/6] Menyimpan kontrak terverifikasi ke database 
2025-12-25 17:33:56.806 INFO:  Preparing contract data for database {
  address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  contractName: 'GoldTokenV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abiLength: 36,
  optimizationUsed: false,
  runs: 200,
  constructorArgumentsLength: 0,
  evmVersion: 'paris',
  sourceFilesCount: 10
}
2025-12-25 17:33:56.806 INFO: [contract.model.js] >> saveVerifiedContract 
2025-12-25 17:33:56.834 INFO:  Kontrak berhasil diverifikasi dan disimpan! 
2025-12-25 17:33:56.834 INFO:  Total waktu verifikasi: 585ms 
2025-12-25 17:33:57.541 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:33:57.541 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=checkverifystatus 
2025-12-25 17:33:57.542 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-12-25 17:33:57.542 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:33:57.551 INFO: [DB Model] Data final yang digabungkan untuk 0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4: {
  query_address: '0x2c2b9c9a4a25e24b174f26114e8926a9f2128fe4',
  contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x078a41be845a417f941327e07e5d8adb0fee0614f3e8ae5e34926042e682aaa3',
  block_number: '34',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'GoldTokenV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:56.807Z,
  sourceFiles: '...'
}
2025-12-25 17:34:18.146 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:18.147 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=getsourcecode 
2025-12-25 17:34:18.147 INFO: [hardhat.handler.js] >> handleGetSourceCode 
2025-12-25 17:34:18.148 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:34:18.174 INFO: [DB Model] Data final yang digabungkan untuk 0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6: {
  query_address: '0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6',
  contract_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x54d11664f24a05b0bb5da9bb13be5d1ba2774864792eda86df3622c86c5009a4',
  block_number: '46',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: null,
  is_verified: false,
  contract_name: null,
  compiler_version: null,
  abi: '...',
  optimization_used: null,
  runs: null,
  constructor_arguments: null,
  evm_version: null,
  verified_at: null,
  sourceFiles: '...'
}
2025-12-25 17:34:18.826 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:18.826 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-12-25 17:34:18.826 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-12-25 17:34:18.826 INFO:  [verification.service.js] >> verify null
2025-12-25 17:34:18.826 INFO:  [verification.validator.js] >> validateAndDefault null
2025-12-25 17:34:18.827 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-12-25 17:34:18.827 INFO:  Parameter validasi berhasil {
  address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  fullContractName: 'contracts/TokenSafeV2.sol:TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '...',
  sourceCodeLength: 11689,
  evmVersion: 'default'
}
2025-12-25 17:34:18.827 INFO:  [verification.bytecode.js] >> getDeployedBytecode null
2025-12-25 17:34:18.827 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6 
2025-12-25 17:34:18.828 INFO:  Connecting to RPC: http://100.92.191.4:8545 null
2025-12-25 17:34:18.905 INFO:  Deployed bytecode berhasil diambil (5836 karakter) 
2025-12-25 17:34:18.905 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:18.906 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:18.906 INFO:  [verification.compiler.js] >> prepareSolcInput null
2025-12-25 17:34:18.906 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-12-25 17:34:18.906 INFO:  Mode deteksi: Standard JSON Input null
2025-12-25 17:34:18.906 INFO:  Input mode: Standard JSON Input 
2025-12-25 17:34:18.907 INFO:  Solc input summary {
  language: 'Solidity',
  sourcesCount: 2,
  sourcesList: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol, contracts/TokenSafeV2.sol',
  mainContract: 'TokenSafeV2',
  contractPath: 'contracts/TokenSafeV2.sol',
  optimizer_enabled: false,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-12-25 17:34:18.907 INFO:  [verification.compiler.js] >> compile null
2025-12-25 17:34:18.907 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-12-25 17:34:19.025 INFO:  Kompilasi selesai dalam 118ms null
2025-12-25 17:34:19.027 INFO:  Kompilasi berhasil tanpa error 
2025-12-25 17:34:19.028 INFO:  [verification.compiler.js] >> extractContractArtifact null
2025-12-25 17:34:19.028 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-12-25 17:34:19.028 INFO:  Contract artifact berhasil diekstrak 
2025-12-25 17:34:19.028 INFO:  [verification.bytecode.js] >> compareBytecodes null
2025-12-25 17:34:19.028 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-12-25 17:34:19.028 INFO:  Menganalisis bytecode yang di-deploy... null
2025-12-25 17:34:19.028 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:19.028 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:19.029 INFO:  Menganalisis bytecode hasil kompilasi... null
2025-12-25 17:34:19.029 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:19.029 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:19.029 INFO: [bytecode.utils.js] >> compareBytecode 
2025-12-25 17:34:19.029 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:19.029 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:19.029 INFO:   Bytecode COCOK! Kontrak terverifikasi.  
2025-12-25 17:34:19.030 INFO:  [verification.db.js] >> saveVerificationResult null
2025-12-25 17:34:19.030 INFO: [6/6] Menyimpan kontrak terverifikasi ke database 
2025-12-25 17:34:19.030 INFO:  Preparing contract data for database {
  address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abiLength: 10,
  optimizationUsed: false,
  runs: 200,
  constructorArgumentsLength: 0,
  evmVersion: 'paris',
  sourceFilesCount: 2
}
2025-12-25 17:34:19.030 INFO: [contract.model.js] >> saveVerifiedContract 
2025-12-25 17:34:19.044 INFO:  Kontrak berhasil diverifikasi dan disimpan! 
2025-12-25 17:34:19.044 INFO:  Total waktu verifikasi: 218ms 
2025-12-25 17:34:19.752 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:19.753 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=checkverifystatus 
2025-12-25 17:34:19.753 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-12-25 17:34:19.753 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:34:19.762 INFO: [DB Model] Data final yang digabungkan untuk 0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6: {
  query_address: '0xfb88de099e13c3ed21f80a7a1e49f8caecf10df6',
  contract_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x54d11664f24a05b0bb5da9bb13be5d1ba2774864792eda86df3622c86c5009a4',
  block_number: '46',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:34:19.031Z,
  sourceFiles: '...'
}
2025-12-25 17:34:35.582 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:35.582 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=getsourcecode 
2025-12-25 17:34:35.583 INFO: [hardhat.handler.js] >> handleGetSourceCode 
2025-12-25 17:34:35.583 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:34:35.623 INFO: [DB Model] Data final yang digabungkan untuk 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10: {
  query_address: '0x345ca3e014aaf5dca488057592ee47305d9b3e10',
  contract_address: '0x345cA3e014Aaf5dcA488057592ee47305D9B3e10',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0xf60a3c94f29036a5e3aeddbd3274ae53f1d98bb7af7acf1fc11922d08c1915a6',
  block_number: '16',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: null,
  is_verified: false,
  contract_name: null,
  compiler_version: null,
  abi: '...',
  optimization_used: null,
  runs: null,
  constructor_arguments: null,
  evm_version: null,
  verified_at: null,
  sourceFiles: '...'
}
2025-12-25 17:34:36.298 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:36.298 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-12-25 17:34:36.299 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-12-25 17:34:36.299 INFO:  [verification.service.js] >> verify null
2025-12-25 17:34:36.299 INFO:  [verification.validator.js] >> validateAndDefault null
2025-12-25 17:34:36.299 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-12-25 17:34:36.299 INFO:  Parameter validasi berhasil {
  address: '0x345cA3e014Aaf5dcA488057592ee47305D9B3e10',
  fullContractName: 'contracts/TokenSafeV1.sol:TokenSafeV1',
  compilerVersion: 'v0.8.28+commit.7893614a',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '...',
  sourceCodeLength: 10886,
  evmVersion: 'default'
}
2025-12-25 17:34:36.300 INFO:  [verification.bytecode.js] >> getDeployedBytecode null
2025-12-25 17:34:36.300 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10 
2025-12-25 17:34:36.300 INFO:  Connecting to RPC: http://100.92.191.4:8545 null
2025-12-25 17:34:36.380 INFO:  Deployed bytecode berhasil diambil (4476 karakter) 
2025-12-25 17:34:36.381 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:36.381 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:36.382 INFO:  [verification.compiler.js] >> prepareSolcInput null
2025-12-25 17:34:36.382 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-12-25 17:34:36.382 INFO:  Mode deteksi: Standard JSON Input null
2025-12-25 17:34:36.382 INFO:  Input mode: Standard JSON Input 
2025-12-25 17:34:36.383 INFO:  Solc input summary {
  language: 'Solidity',
  sourcesCount: 2,
  sourcesList: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol, contracts/TokenSafeV1.sol',
  mainContract: 'TokenSafeV1',
  contractPath: 'contracts/TokenSafeV1.sol',
  optimizer_enabled: false,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-12-25 17:34:36.383 INFO:  [verification.compiler.js] >> compile null
2025-12-25 17:34:36.383 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-12-25 17:34:36.473 INFO:  Kompilasi selesai dalam 89ms null
2025-12-25 17:34:36.475 INFO:  Kompilasi berhasil tanpa error 
2025-12-25 17:34:36.475 INFO:  [verification.compiler.js] >> extractContractArtifact null
2025-12-25 17:34:36.475 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-12-25 17:34:36.475 INFO:  Contract artifact berhasil diekstrak 
2025-12-25 17:34:36.475 INFO:  [verification.bytecode.js] >> compareBytecodes null
2025-12-25 17:34:36.475 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-12-25 17:34:36.475 INFO:  Menganalisis bytecode yang di-deploy... null
2025-12-25 17:34:36.475 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:36.475 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:36.475 INFO:  Menganalisis bytecode hasil kompilasi... null
2025-12-25 17:34:36.475 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:36.476 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:36.476 INFO: [bytecode.utils.js] >> compareBytecode 
2025-12-25 17:34:36.476 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:36.476 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:36.476 INFO:   Bytecode COCOK! Kontrak terverifikasi.  
2025-12-25 17:34:36.476 INFO:  [verification.db.js] >> saveVerificationResult null
2025-12-25 17:34:36.476 INFO: [6/6] Menyimpan kontrak terverifikasi ke database 
2025-12-25 17:34:36.476 INFO:  Preparing contract data for database {
  address: '0x345cA3e014Aaf5dcA488057592ee47305D9B3e10',
  contractName: 'TokenSafeV1',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abiLength: 9,
  optimizationUsed: false,
  runs: 200,
  constructorArgumentsLength: 0,
  evmVersion: 'paris',
  sourceFilesCount: 2
}
2025-12-25 17:34:36.477 INFO: [contract.model.js] >> saveVerifiedContract 
2025-12-25 17:34:36.488 INFO:  Kontrak berhasil diverifikasi dan disimpan! 
2025-12-25 17:34:36.488 INFO:  Total waktu verifikasi: 189ms 
2025-12-25 17:34:37.195 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:37.195 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=checkverifystatus 
2025-12-25 17:34:37.196 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-12-25 17:34:37.196 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:34:37.204 INFO: [DB Model] Data final yang digabungkan untuk 0x345cA3e014Aaf5dcA488057592ee47305D9B3e10: {
  query_address: '0x345ca3e014aaf5dca488057592ee47305d9b3e10',
  contract_address: '0x345cA3e014Aaf5dcA488057592ee47305D9B3e10',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0xf60a3c94f29036a5e3aeddbd3274ae53f1d98bb7af7acf1fc11922d08c1915a6',
  block_number: '16',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x345cA3e014Aaf5dcA488057592ee47305D9B3e10',
  is_verified: true,
  contract_name: 'TokenSafeV1',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:34:36.477Z,
  sourceFiles: '...'
}
2025-12-25 17:34:53.691 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:53.691 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=getsourcecode 
2025-12-25 17:34:53.691 INFO: [hardhat.handler.js] >> handleGetSourceCode 
2025-12-25 17:34:53.691 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:34:53.714 INFO: [DB Model] Data final yang digabungkan untuk 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0: {
  query_address: '0x8cdaf0cd259887258bc13a92c0a6da92698644c0',
  contract_address: '0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0xb409728d2c2bfb6b4b0f44d44c69fc50ac4240b5bb25638c2118898e302cc728',
  block_number: '11',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: null,
  is_verified: false,
  contract_name: null,
  compiler_version: null,
  abi: '...',
  optimization_used: null,
  runs: null,
  constructor_arguments: null,
  evm_version: null,
  verified_at: null,
  sourceFiles: '...'
}
2025-12-25 17:34:54.412 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:54.413 INFO: [API] Menerima permintaan Hardhat: method=POST, module=contract, action=verifysourcecode 
2025-12-25 17:34:54.413 INFO: [hardhat.handler.js] >> handleVerifySourceCode 
2025-12-25 17:34:54.413 INFO:  [verification.service.js] >> verify null
2025-12-25 17:34:54.413 INFO:  [verification.validator.js] >> validateAndDefault null
2025-12-25 17:34:54.413 INFO: [0/6] Memulai Proses Verifikasi Kontrak 
2025-12-25 17:34:54.414 INFO:  Parameter validasi berhasil {
  address: '0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0',
  fullContractName: 'contracts/GoldTokenV1.sol:GoldTokenV1',
  compilerVersion: 'v0.8.28+commit.7893614a',
  optimizationUsed: false,
  runs: 0,
  constructorArgsPreview: '...',
  sourceCodeLength: 39400,
  evmVersion: 'default'
}
2025-12-25 17:34:54.414 INFO:  [verification.bytecode.js] >> getDeployedBytecode null
2025-12-25 17:34:54.414 INFO: [1/6] Mengambil bytecode dari blockchain untuk alamat: 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0 
2025-12-25 17:34:54.414 INFO:  Connecting to RPC: http://100.92.191.4:8545 null
2025-12-25 17:34:54.504 INFO:  Deployed bytecode berhasil diambil (13106 karakter) 
2025-12-25 17:34:54.505 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:54.505 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:54.507 INFO:  [verification.compiler.js] >> prepareSolcInput null
2025-12-25 17:34:54.508 INFO: [2/6] Menyiapkan input untuk kompilasi solc 
2025-12-25 17:34:54.508 INFO:  Mode deteksi: Standard JSON Input null
2025-12-25 17:34:54.509 INFO:  Input mode: Standard JSON Input 
2025-12-25 17:34:54.510 INFO:  Solc input summary {
  language: 'Solidity',
  sourcesCount: 8,
  sourcesList: '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol, @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol, @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol, @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol, @openzeppelin/contracts/interfaces/draft-IERC6093.sol, @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol, @openzeppelin/contracts/token/ERC20/IERC20.sol, contracts/GoldTokenV1.sol',
  mainContract: 'GoldTokenV1',
  contractPath: 'contracts/GoldTokenV1.sol',
  optimizer_enabled: false,
  optimizer_runs: 200,
  evm_version: 'paris'
}
2025-12-25 17:34:54.510 INFO:  [verification.compiler.js] >> compile null
2025-12-25 17:34:54.511 INFO: [3/6] Mengkompilasi kode sumber dengan solc 
2025-12-25 17:34:54.803 INFO:  Kompilasi selesai dalam 291ms null
2025-12-25 17:34:54.807 INFO:  Kompilasi berhasil tanpa error 
2025-12-25 17:34:54.807 INFO:  [verification.compiler.js] >> extractContractArtifact null
2025-12-25 17:34:54.807 INFO: [4/6] Mengekstrak artifak kontrak hasil kompilasi 
2025-12-25 17:34:54.807 INFO:  Contract artifact berhasil diekstrak 
2025-12-25 17:34:54.807 INFO:  [verification.bytecode.js] >> compareBytecodes null
2025-12-25 17:34:54.807 INFO: [5/6] Membandingkan bytecode deployed vs compiled 
2025-12-25 17:34:54.807 INFO:  Menganalisis bytecode yang di-deploy... null
2025-12-25 17:34:54.807 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:54.808 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:54.808 INFO:  Menganalisis bytecode hasil kompilasi... null
2025-12-25 17:34:54.808 INFO: [bytecode.utils.js] >> analyzeBytecode 
2025-12-25 17:34:54.808 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:54.810 INFO: [bytecode.utils.js] >> compareBytecode 
2025-12-25 17:34:54.810 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:54.810 INFO: [bytecode.utils.js] >> stripMetadata 
2025-12-25 17:34:54.811 INFO:   Bytecode COCOK! Kontrak terverifikasi.  
2025-12-25 17:34:54.812 INFO:  [verification.db.js] >> saveVerificationResult null
2025-12-25 17:34:54.812 INFO: [6/6] Menyimpan kontrak terverifikasi ke database 
2025-12-25 17:34:54.812 INFO:  Preparing contract data for database {
  address: '0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0',
  contractName: 'GoldTokenV1',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abiLength: 28,
  optimizationUsed: false,
  runs: 200,
  constructorArgumentsLength: 0,
  evmVersion: 'paris',
  sourceFilesCount: 8
}
2025-12-25 17:34:54.812 INFO: [contract.model.js] >> saveVerifiedContract 
2025-12-25 17:34:54.827 INFO:  Kontrak berhasil diverifikasi dan disimpan! 
2025-12-25 17:34:54.827 INFO:  Total waktu verifikasi: 414ms 
2025-12-25 17:34:55.535 INFO: [hardhat.handler.js] >> handleHardhatVerification 
2025-12-25 17:34:55.536 INFO: [API] Menerima permintaan Hardhat: method=GET, module=contract, action=checkverifystatus 
2025-12-25 17:34:55.536 INFO: [hardhat.handler.js] >> handleCheckVerifyStatus 
2025-12-25 17:34:55.536 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:34:55.545 INFO: [DB Model] Data final yang digabungkan untuk 0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0: {
  query_address: '0x8cdaf0cd259887258bc13a92c0a6da92698644c0',
  contract_address: '0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0xb409728d2c2bfb6b4b0f44d44c69fc50ac4240b5bb25638c2118898e302cc728',
  block_number: '11',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0x8CdaF0CD259887258Bc13a92C0a6dA92698644C0',
  is_verified: true,
  contract_name: 'GoldTokenV1',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:34:54.813Z,
  sourceFiles: '...'
}
2025-12-25 17:35:54.425 INFO: [contract.resolver.js] >> Query.contracts 
2025-12-25 17:35:54.425 INFO: [contract.service.js] >> getContracts 
2025-12-25 17:35:54.426 INFO: [API Service] Fetching all contracts 
2025-12-25 17:35:54.426 INFO: [contract.model.js] >> getContracts 
2025-12-25 17:36:42.803 INFO: [contract.resolver.js] >> Query.contracts 
2025-12-25 17:36:42.803 INFO: [contract.service.js] >> getContracts 
2025-12-25 17:36:42.803 INFO: [API Service] Fetching all contracts 
2025-12-25 17:36:42.804 INFO: [contract.model.js] >> getContracts 
2025-12-25 17:37:06.700 INFO: [contract.resolver.js] >> Query.contract 
2025-12-25 17:37:06.701 INFO: [contract.service.js] >> getContractByAddress 
2025-12-25 17:37:06.701 INFO: [API Service] Fetching contract data for address: 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF 
2025-12-25 17:37:06.701 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:37:06.735 INFO: [DB Model] Data final yang digabungkan untuk 0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '18',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:34:19.031Z,
  sourceFiles: '...'
}
2025-12-25 17:37:06.735 INFO: [API Service] Raw data from model: {
  query_address: '0xf25186b5081ff5ce73482ad761db0eb0d25abfbf',
  contract_address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  block_number: '18',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  admin_address: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  verified_contract_address: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  is_verified: true,
  contract_name: 'TokenSafeV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:34:19.031Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-12-25 17:37:06.743 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xf25186B5081Ff5cE73482AD761DB0eB0d25abfBF',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x41ad4214024926096f3e99f2d6a005a6e3dbb90e5d6010c98218ab0d8d54e507',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: 'contracts/TokenSafeV2.sol',
      sourceCode: '// contracts/TokenSafeV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        '\n' +
        '// Interface IGoldToken tetap sama\n' +
        'interface IGoldToken {\n' +
        '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n' +
        '    // Kita butuh fungsi transfer untuk mengirim token KEMBALI ke user\n' +
        '    function transfer(address recipient, uint256 amount) external returns (bool);\n' +
        '}\n' +
        '\n' +
        'contract TokenSafeV2 is Initializable {\n' +
        '    IGoldToken public goldToken;\n' +
        '    address public owner;\n' +
        '\n' +
        '    mapping(address => uint256) public lockedBalances;\n' +
        '\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    // Initializer tidak perlu diubah\n' +
        '    function initialize(address _tokenAddress) public initializer {\n' +
        '        goldToken = IGoldToken(_tokenAddress);\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi lockTokens tetap sama\n' +
        '    function lockTokens(uint256 _amount) public {\n' +
        '        require(goldToken.transferFrom(msg.sender, address(this), _amount), "Token transfer failed");\n' +
        '        lockedBalances[msg.sender] += _amount;\n' +
        '    }\n' +
        '\n' +
        '    // FUNGSI BARU UNTUK MENGAMBIL TOKEN\n' +
        '    function unlockTokens(uint256 _amount) public {\n' +
        '        // 1. Pastikan user memiliki cukup saldo yang terkunci\n' +
        '        require(lockedBalances[msg.sender] >= _amount, "Insufficient locked balance");\n' +
        '\n' +
        '        // 2. Kurangi catatan saldo yang terkunci\n' +
        '        lockedBalances[msg.sender] -= _amount;\n' +
        '\n' +
        '        // 3. Perintahkan kontrak GoldToken untuk mengirim token dari brankas (this) ke user (msg.sender)\n' +
        '        require(goldToken.transfer(msg.sender, _amount), "Token transfer failed");\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenSafeV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'goldToken',
      type: 'function',
      inputs: [],
      outputs: [
        {
          name: '',
          type: 'address',
          internalType: 'contract IGoldToken'
        }
      ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'lockedBalances',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'unlockTokens',
      type: 'function',
      inputs: [ { name: '_amount', type: 'uint256', internalType: 'uint256' } ],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0xFB88dE099e13c3ED21F80a7a1E49f8CAEcF10df6',
  adminAddress: '0xB9462EF3441346dBc6E49236Edbb0dF207db09B7',
  blockNumber: '18'
}
2025-12-25 17:37:12.637 INFO: [contract.resolver.js] >> Query.contracts 
2025-12-25 17:37:12.637 INFO: [contract.service.js] >> getContracts 
2025-12-25 17:37:12.637 INFO: [API Service] Fetching all contracts 
2025-12-25 17:37:12.637 INFO: [contract.model.js] >> getContracts 
2025-12-25 17:37:13.923 INFO: [contract.resolver.js] >> Query.contract 
2025-12-25 17:37:13.923 INFO: [contract.service.js] >> getContractByAddress 
2025-12-25 17:37:13.923 INFO: [API Service] Fetching contract data for address: 0xeec918d74c746167564401103096D45BbD494B74 
2025-12-25 17:37:13.924 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:37:13.927 INFO: [DB Model] Data final yang digabungkan untuk 0xeec918d74c746167564401103096D45BbD494B74: {
  query_address: '0xeec918d74c746167564401103096d45bbd494b74',
  contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  block_number: '79',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  is_verified: true,
  contract_name: 'TokenRegistry',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:34.067Z,
  sourceFiles: '...'
}
2025-12-25 17:37:13.927 INFO: [API Service] Raw data from model: {
  query_address: '0xeec918d74c746167564401103096d45bbd494b74',
  contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  block_number: '79',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  is_verified: true,
  contract_name: 'TokenRegistry',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    {
      name: 'LogoUpdated',
      type: 'event',
      inputs: [
        {
          name: 'tokenAddress',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'LogoUrl',
          type: 'string',
          indexed: false,
          internalType: 'string'
        },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          indexed: false,
          internalType: 'bytes32'
        },
        {
          name: 'timestamp',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'OwnershipTransferred',
      type: 'event',
      inputs: [
        {
          name: 'previousOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'newOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'getTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoData',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bytes32', internalType: 'bytes32' } ],
      stateMutability: 'view'
    },
    {
      name: 'hasLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'removeLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'setTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        { name: '_url', type: 'string', internalType: 'string' },
        {
          name: '_sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'tokenLogos',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'transferOwnership',
      type: 'function',
      inputs: [
        { name: '_newOwner', type: 'address', internalType: 'address' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'verifyLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        {
          name: '_providedHash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:34.067Z,
  sourceFiles: [
    {
      filePath: 'contracts/TokenRegistry.sol',
      sourceCode: 'pragma solidity ^0.8.0;\n' +
        '\n' +
        'contract TokenRegistry{\n' +
        '    address public owner;\n' +
        '\n' +
        '    struct TokenLogo{\n' +
        '        string url;\n' +
        '        bytes32 sha256Hash;\n' +
        '        uint256 timestamp;\n' +
        '    }\n' +
        '\n' +
        '    mapping(address => TokenLogo) public tokenLogos;\n' +
        '\n' +
        '    event LogoUpdated (\n' +
        '        address indexed tokenAddress,\n' +
        '        string LogoUrl,\n' +
        '        bytes32 sha256Hash,\n' +
        '        uint256 timestamp\n' +
        '    );\n' +
        '\n' +
        '    event OwnershipTransferred(\n' +
        '        address indexed previousOwner, \n' +
        '        address indexed newOwner\n' +
        '    );\n' +
        '    \n' +
        '    constructor() {\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '    \n' +
        '    // Modifier: Hanya admin yang boleh akses\n' +
        '    modifier onlyOwner() {\n' +
        '        require(msg.sender == owner, "Hanya Admin yang boleh atur logo!");\n' +
        '        _;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Set logo token dengan URL dan hash SHA256\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _url URL logo token (IPFS, HTTP, dll)\n' +
        '     * @param _sha256Hash Hash SHA256 dari file gambar (hasil dari sha256sum)\n' +
        '     * \n' +
        '     * Cara generate hash di Linux:\n' +
        '     * sha256sum logo.png\n' +
        '     * Output: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n' +
        '     */\n' +
        '    function setTokenLogo(\n' +
        '        address _tokenAddress, \n' +
        '        string memory _url, \n' +
        '        bytes32 _sha256Hash\n' +
        '    ) public onlyOwner {\n' +
        '        require(_tokenAddress != address(0), "Alamat token tidak valid!");\n' +
        '        require(bytes(_url).length > 0, "URL tidak boleh kosong!");\n' +
        '        require(_sha256Hash != bytes32(0), "Hash tidak boleh kosong!");\n' +
        '        \n' +
        '        tokenLogos[_tokenAddress] = TokenLogo({\n' +
        '            url: _url,\n' +
        '            sha256Hash: _sha256Hash,\n' +
        '            timestamp: block.timestamp\n' +
        '        });\n' +
        '        \n' +
        '        emit LogoUpdated(_tokenAddress, _url, _sha256Hash, block.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil URL logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return URL logo\n' +
        '     */\n' +
        '    function getTokenLogo(address _tokenAddress) public view returns (string memory) {\n' +
        '        return tokenLogos[_tokenAddress].url;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil hash SHA256 logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return Hash SHA256\n' +
        '     */\n' +
        '    function getTokenLogoHash(address _tokenAddress) public view returns (bytes32) {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil semua data logo token (URL, Hash, Timestamp)\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return url URL logo\n' +
        '     * @return sha256Hash Hash SHA256\n' +
        '     * @return timestamp Waktu update terakhir\n' +
        '     */\n' +
        '    function getTokenLogoData(address _tokenAddress) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (\n' +
        '            string memory url, \n' +
        '            bytes32 sha256Hash, \n' +
        '            uint256 timestamp\n' +
        '        ) \n' +
        '    {\n' +
        '        TokenLogo memory logo = tokenLogos[_tokenAddress];\n' +
        '        return (logo.url, logo.sha256Hash, logo.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Verifikasi apakah hash sesuai dengan yang tersimpan\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _providedHash Hash yang akan diverifikasi\n' +
        '     * @return true jika hash cocok\n' +
        '     */\n' +
        '    function verifyLogoHash(address _tokenAddress, bytes32 _providedHash) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (bool) \n' +
        '    {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash == _providedHash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Cek apakah token sudah punya logo\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return true jika logo sudah diset\n' +
        '     */\n' +
        '    function hasLogo(address _tokenAddress) public view returns (bool) {\n' +
        '        return bytes(tokenLogos[_tokenAddress].url).length > 0;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Transfer ownership ke address baru\n' +
        '     * @param _newOwner Address owner baru\n' +
        '     */\n' +
        '    function transferOwnership(address _newOwner) public onlyOwner {\n' +
        '        require(_newOwner != address(0), "Owner baru tidak valid!");\n' +
        '        address oldOwner = owner;\n' +
        '        owner = _newOwner;\n' +
        '        emit OwnershipTransferred(oldOwner, _newOwner);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Hapus logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     */\n' +
        '    function removeLogo(address _tokenAddress) public onlyOwner {\n' +
        '        delete tokenLogos[_tokenAddress];\n' +
        '        emit LogoUpdated(_tokenAddress, "", bytes32(0), block.timestamp);\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-12-25 17:37:13.930 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xeec918d74c746167564401103096D45BbD494B74',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  isVerified: true,
  sourceFiles: [
    {
      filePath: 'contracts/TokenRegistry.sol',
      sourceCode: 'pragma solidity ^0.8.0;\n' +
        '\n' +
        'contract TokenRegistry{\n' +
        '    address public owner;\n' +
        '\n' +
        '    struct TokenLogo{\n' +
        '        string url;\n' +
        '        bytes32 sha256Hash;\n' +
        '        uint256 timestamp;\n' +
        '    }\n' +
        '\n' +
        '    mapping(address => TokenLogo) public tokenLogos;\n' +
        '\n' +
        '    event LogoUpdated (\n' +
        '        address indexed tokenAddress,\n' +
        '        string LogoUrl,\n' +
        '        bytes32 sha256Hash,\n' +
        '        uint256 timestamp\n' +
        '    );\n' +
        '\n' +
        '    event OwnershipTransferred(\n' +
        '        address indexed previousOwner, \n' +
        '        address indexed newOwner\n' +
        '    );\n' +
        '    \n' +
        '    constructor() {\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '    \n' +
        '    // Modifier: Hanya admin yang boleh akses\n' +
        '    modifier onlyOwner() {\n' +
        '        require(msg.sender == owner, "Hanya Admin yang boleh atur logo!");\n' +
        '        _;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Set logo token dengan URL dan hash SHA256\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _url URL logo token (IPFS, HTTP, dll)\n' +
        '     * @param _sha256Hash Hash SHA256 dari file gambar (hasil dari sha256sum)\n' +
        '     * \n' +
        '     * Cara generate hash di Linux:\n' +
        '     * sha256sum logo.png\n' +
        '     * Output: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n' +
        '     */\n' +
        '    function setTokenLogo(\n' +
        '        address _tokenAddress, \n' +
        '        string memory _url, \n' +
        '        bytes32 _sha256Hash\n' +
        '    ) public onlyOwner {\n' +
        '        require(_tokenAddress != address(0), "Alamat token tidak valid!");\n' +
        '        require(bytes(_url).length > 0, "URL tidak boleh kosong!");\n' +
        '        require(_sha256Hash != bytes32(0), "Hash tidak boleh kosong!");\n' +
        '        \n' +
        '        tokenLogos[_tokenAddress] = TokenLogo({\n' +
        '            url: _url,\n' +
        '            sha256Hash: _sha256Hash,\n' +
        '            timestamp: block.timestamp\n' +
        '        });\n' +
        '        \n' +
        '        emit LogoUpdated(_tokenAddress, _url, _sha256Hash, block.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil URL logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return URL logo\n' +
        '     */\n' +
        '    function getTokenLogo(address _tokenAddress) public view returns (string memory) {\n' +
        '        return tokenLogos[_tokenAddress].url;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil hash SHA256 logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return Hash SHA256\n' +
        '     */\n' +
        '    function getTokenLogoHash(address _tokenAddress) public view returns (bytes32) {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil semua data logo token (URL, Hash, Timestamp)\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return url URL logo\n' +
        '     * @return sha256Hash Hash SHA256\n' +
        '     * @return timestamp Waktu update terakhir\n' +
        '     */\n' +
        '    function getTokenLogoData(address _tokenAddress) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (\n' +
        '            string memory url, \n' +
        '            bytes32 sha256Hash, \n' +
        '            uint256 timestamp\n' +
        '        ) \n' +
        '    {\n' +
        '        TokenLogo memory logo = tokenLogos[_tokenAddress];\n' +
        '        return (logo.url, logo.sha256Hash, logo.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Verifikasi apakah hash sesuai dengan yang tersimpan\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _providedHash Hash yang akan diverifikasi\n' +
        '     * @return true jika hash cocok\n' +
        '     */\n' +
        '    function verifyLogoHash(address _tokenAddress, bytes32 _providedHash) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (bool) \n' +
        '    {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash == _providedHash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Cek apakah token sudah punya logo\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return true jika logo sudah diset\n' +
        '     */\n' +
        '    function hasLogo(address _tokenAddress) public view returns (bool) {\n' +
        '        return bytes(tokenLogos[_tokenAddress].url).length > 0;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Transfer ownership ke address baru\n' +
        '     * @param _newOwner Address owner baru\n' +
        '     */\n' +
        '    function transferOwnership(address _newOwner) public onlyOwner {\n' +
        '        require(_newOwner != address(0), "Owner baru tidak valid!");\n' +
        '        address oldOwner = owner;\n' +
        '        owner = _newOwner;\n' +
        '        emit OwnershipTransferred(oldOwner, _newOwner);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Hapus logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     */\n' +
        '    function removeLogo(address _tokenAddress) public onlyOwner {\n' +
        '        delete tokenLogos[_tokenAddress];\n' +
        '        emit LogoUpdated(_tokenAddress, "", bytes32(0), block.timestamp);\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenRegistry',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    {
      name: 'LogoUpdated',
      type: 'event',
      inputs: [
        {
          name: 'tokenAddress',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'LogoUrl',
          type: 'string',
          indexed: false,
          internalType: 'string'
        },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          indexed: false,
          internalType: 'bytes32'
        },
        {
          name: 'timestamp',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'OwnershipTransferred',
      type: 'event',
      inputs: [
        {
          name: 'previousOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'newOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'getTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoData',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bytes32', internalType: 'bytes32' } ],
      stateMutability: 'view'
    },
    {
      name: 'hasLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'removeLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'setTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        { name: '_url', type: 'string', internalType: 'string' },
        {
          name: '_sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'tokenLogos',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'transferOwnership',
      type: 'function',
      inputs: [
        { name: '_newOwner', type: 'address', internalType: 'address' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'verifyLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        {
          name: '_providedHash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '79'
}
2025-12-25 17:47:41.451 INFO: [contract.resolver.js] >> Query.contracts 
2025-12-25 17:47:41.451 INFO: [contract.service.js] >> getContracts 
2025-12-25 17:47:41.451 INFO: [API Service] Fetching all contracts 
2025-12-25 17:47:41.451 INFO: [contract.model.js] >> getContracts 
2025-12-25 17:47:44.989 INFO: [contract.resolver.js] >> Query.contract 
2025-12-25 17:47:44.989 INFO: [contract.service.js] >> getContractByAddress 
2025-12-25 17:47:44.989 INFO: [API Service] Fetching contract data for address: 0xF12b5dd4EAD5F743C6BaA640B0216200e89B60Da 
2025-12-25 17:47:44.989 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:47:44.994 INFO: [DB Model] Data final yang digabungkan untuk 0xF12b5dd4EAD5F743C6BaA640B0216200e89B60Da: {
  query_address: '0xf12b5dd4ead5f743c6baa640b0216200e89b60da',
  contract_address: '0xF12b5dd4EAD5F743C6BaA640B0216200e89B60Da',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0xfb467656fa29b7626ed42d656036b66748adbc417ea1f7646f901baf7b7ffaf4',
  block_number: '12',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0x6512a267aD28dFE41a5846E7aD0B2501633cB3f2',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'GoldTokenV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:56.807Z,
  sourceFiles: '...'
}
2025-12-25 17:47:44.995 INFO: [API Service] Raw data from model: {
  query_address: '0xf12b5dd4ead5f743c6baa640b0216200e89b60da',
  contract_address: '0xF12b5dd4EAD5F743C6BaA640B0216200e89B60Da',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0xfb467656fa29b7626ed42d656036b66748adbc417ea1f7646f901baf7b7ffaf4',
  block_number: '12',
  is_proxy: true,
  proxy_type: 'eip1967',
  implementation_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  admin_address: '0x6512a267aD28dFE41a5846E7aD0B2501633cB3f2',
  verified_contract_address: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  is_verified: true,
  contract_name: 'GoldTokenV2',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    {
      name: 'ERC20InsufficientAllowance',
      type: 'error',
      inputs: [
        { name: 'spender', type: 'address', internalType: 'address' },
        { name: 'allowance', type: 'uint256', internalType: 'uint256' },
        { name: 'needed', type: 'uint256', internalType: 'uint256' }
      ]
    },
    {
      name: 'ERC20InsufficientBalance',
      type: 'error',
      inputs: [
        { name: 'sender', type: 'address', internalType: 'address' },
        { name: 'balance', type: 'uint256', internalType: 'uint256' },
        { name: 'needed', type: 'uint256', internalType: 'uint256' }
      ]
    },
    {
      name: 'ERC20InvalidApprover',
      type: 'error',
      inputs: [
        { name: 'approver', type: 'address', internalType: 'address' }
      ]
    },
    {
      name: 'ERC20InvalidReceiver',
      type: 'error',
      inputs: [
        { name: 'receiver', type: 'address', internalType: 'address' }
      ]
    },
    {
      name: 'ERC20InvalidSender',
      type: 'error',
      inputs: [ { name: 'sender', type: 'address', internalType: 'address' } ]
    },
    {
      name: 'ERC20InvalidSpender',
      type: 'error',
      inputs: [ { name: 'spender', type: 'address', internalType: 'address' } ]
    },
    { name: 'EnforcedPause', type: 'error', inputs: [] },
    { name: 'ExpectedPause', type: 'error', inputs: [] },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'OwnableInvalidOwner',
      type: 'error',
      inputs: [ { name: 'owner', type: 'address', internalType: 'address' } ]
    },
    {
      name: 'OwnableUnauthorizedAccount',
      type: 'error',
      inputs: [ { name: 'account', type: 'address', internalType: 'address' } ]
    },
    {
      name: 'Approval',
      type: 'event',
      inputs: [
        {
          name: 'owner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'spender',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'value',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'OwnershipTransferred',
      type: 'event',
      inputs: [
        {
          name: 'previousOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'newOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'Paused',
      type: 'event',
      inputs: [
        {
          name: 'account',
          type: 'address',
          indexed: false,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'Transfer',
      type: 'event',
      inputs: [
        {
          name: 'from',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'to',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'value',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'Unpaused',
      type: 'event',
      inputs: [
        {
          name: 'account',
          type: 'address',
          indexed: false,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'allowance',
      type: 'function',
      inputs: [
        { name: 'owner', type: 'address', internalType: 'address' },
        { name: 'spender', type: 'address', internalType: 'address' }
      ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'approve',
      type: 'function',
      inputs: [
        { name: 'spender', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'nonpayable'
    },
    {
      name: 'balanceOf',
      type: 'function',
      inputs: [ { name: 'account', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'decimals',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'uint8', internalType: 'uint8' } ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_initialSupply',
          type: 'uint256',
          internalType: 'uint256'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'mint',
      type: 'function',
      inputs: [
        { name: 'to', type: 'address', internalType: 'address' },
        { name: 'amount', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'name',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'pause',
      type: 'function',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'paused',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    },
    {
      name: 'renounceOwnership',
      type: 'function',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'symbol',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'totalSupply',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'transfer',
      type: 'function',
      inputs: [
        { name: 'to', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'nonpayable'
    },
    {
      name: 'transferFrom',
      type: 'function',
      inputs: [
        { name: 'from', type: 'address', internalType: 'address' },
        { name: 'to', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'nonpayable'
    },
    {
      name: 'transferOwnership',
      type: 'function',
      inputs: [
        { name: 'newOwner', type: 'address', internalType: 'address' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'unpause',
      type: 'function',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:56.807Z,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";\n' +
        'import {Initializable} from "../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Contract module which provides a basic access control mechanism, where\n' +
        ' * there is an account (an owner) that can be granted exclusive access to\n' +
        ' * specific functions.\n' +
        ' *\n' +
        ' * The initial owner is set to the address provided by the deployer. This can\n' +
        ' * later be changed with {transferOwnership}.\n' +
        ' *\n' +
        ' * This module is used through inheritance. It will make available the modifier\n' +
        ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n' +
        ' * the owner.\n' +
        ' */\n' +
        'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n' +
        '    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n' +
        '    struct OwnableStorage {\n' +
        '        address _owner;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n' +
        '\n' +
        '    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n' +
        '        assembly {\n' +
        '            $.slot := OwnableStorageLocation\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The caller account is not authorized to perform an operation.\n' +
        '     */\n' +
        '    error OwnableUnauthorizedAccount(address account);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n' +
        '     */\n' +
        '    error OwnableInvalidOwner(address owner);\n' +
        '\n' +
        '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n' +
        '     */\n' +
        '    function __Ownable_init(address initialOwner) internal onlyInitializing {\n' +
        '        __Ownable_init_unchained(initialOwner);\n' +
        '    }\n' +
        '\n' +
        '    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n' +
        '        if (initialOwner == address(0)) {\n' +
        '            revert OwnableInvalidOwner(address(0));\n' +
        '        }\n' +
        '        _transferOwnership(initialOwner);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if called by any account other than the owner.\n' +
        '     */\n' +
        '    modifier onlyOwner() {\n' +
        '        _checkOwner();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the address of the current owner.\n' +
        '     */\n' +
        '    function owner() public view virtual returns (address) {\n' +
        '        OwnableStorage storage $ = _getOwnableStorage();\n' +
        '        return $._owner;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if the sender is not the owner.\n' +
        '     */\n' +
        '    function _checkOwner() internal view virtual {\n' +
        '        if (owner() != _msgSender()) {\n' +
        '            revert OwnableUnauthorizedAccount(_msgSender());\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Leaves the contract without owner. It will not be possible to call\n' +
        '     * `onlyOwner` functions. Can only be called by the current owner.\n' +
        '     *\n' +
        '     * NOTE: Renouncing ownership will leave the contract without an owner,\n' +
        '     * thereby disabling any functionality that is only available to the owner.\n' +
        '     */\n' +
        '    function renounceOwnership() public virtual onlyOwner {\n' +
        '        _transferOwnership(address(0));\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n' +
        '     * Can only be called by the current owner.\n' +
        '     */\n' +
        '    function transferOwnership(address newOwner) public virtual onlyOwner {\n' +
        '        if (newOwner == address(0)) {\n' +
        '            revert OwnableInvalidOwner(address(0));\n' +
        '        }\n' +
        '        _transferOwnership(newOwner);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n' +
        '     * Internal function without access restriction.\n' +
        '     */\n' +
        '    function _transferOwnership(address newOwner) internal virtual {\n' +
        '        OwnableStorage storage $ = _getOwnableStorage();\n' +
        '        address oldOwner = $._owner;\n' +
        '        $._owner = newOwner;\n' +
        '        emit OwnershipTransferred(oldOwner, newOwner);\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n' +
        'import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";\n' +
        'import {ContextUpgradeable} from "../../utils/ContextUpgradeable.sol";\n' +
        'import {IERC20Errors} from "@openzeppelin/contracts/interfaces/draft-IERC6093.sol";\n' +
        'import {Initializable} from "../../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Implementation of the {IERC20} interface.\n' +
        ' *\n' +
        ' * This implementation is agnostic to the way tokens are created. This means\n' +
        ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n' +
        ' *\n' +
        ' * TIP: For a detailed writeup see our guide\n' +
        ' * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n' +
        ' * to implement supply mechanisms].\n' +
        ' *\n' +
        ' * The default value of {decimals} is 18. To change this, you should override\n' +
        ' * this function so it returns a different value.\n' +
        ' *\n' +
        ' * We have followed general OpenZeppelin Contracts guidelines: functions revert\n' +
        ' * instead returning `false` on failure. This behavior is nonetheless\n' +
        ' * conventional and does not conflict with the expectations of ERC-20\n' +
        ' * applications.\n' +
        ' */\n' +
        'abstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n' +
        '    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n' +
        '    struct ERC20Storage {\n' +
        '        mapping(address account => uint256) _balances;\n' +
        '\n' +
        '        mapping(address account => mapping(address spender => uint256)) _allowances;\n' +
        '\n' +
        '        uint256 _totalSupply;\n' +
        '\n' +
        '        string _name;\n' +
        '        string _symbol;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ERC20")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n' +
        '\n' +
        '    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n' +
        '        assembly {\n' +
        '            $.slot := ERC20StorageLocation\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Sets the values for {name} and {symbol}.\n' +
        '     *\n' +
        '     * Both values are immutable: they can only be set once during construction.\n' +
        '     */\n' +
        '    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n' +
        '        __ERC20_init_unchained(name_, symbol_);\n' +
        '    }\n' +
        '\n' +
        '    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        $._name = name_;\n' +
        '        $._symbol = symbol_;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the name of the token.\n' +
        '     */\n' +
        '    function name() public view virtual returns (string memory) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._name;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the symbol of the token, usually a shorter version of the\n' +
        '     * name.\n' +
        '     */\n' +
        '    function symbol() public view virtual returns (string memory) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._symbol;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the number of decimals used to get its user representation.\n' +
        '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n' +
        '     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n' +
        '     *\n' +
        '     * Tokens usually opt for a value of 18, imitating the relationship between\n' +
        '     * Ether and Wei. This is the default value returned by this function, unless\n' +
        "     * it's overridden.\n" +
        '     *\n' +
        '     * NOTE: This information is only used for _display_ purposes: it in\n' +
        '     * no way affects any of the arithmetic of the contract, including\n' +
        '     * {IERC20-balanceOf} and {IERC20-transfer}.\n' +
        '     */\n' +
        '    function decimals() public view virtual returns (uint8) {\n' +
        '        return 18;\n' +
        '    }\n' +
        '\n' +
        '    /// @inheritdoc IERC20\n' +
        '    function totalSupply() public view virtual returns (uint256) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._totalSupply;\n' +
        '    }\n' +
        '\n' +
        '    /// @inheritdoc IERC20\n' +
        '    function balanceOf(address account) public view virtual returns (uint256) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._balances[account];\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev See {IERC20-transfer}.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `to` cannot be the zero address.\n' +
        '     * - the caller must have a balance of at least `value`.\n' +
        '     */\n' +
        '    function transfer(address to, uint256 value) public virtual returns (bool) {\n' +
        '        address owner = _msgSender();\n' +
        '        _transfer(owner, to, value);\n' +
        '        return true;\n' +
        '    }\n' +
        '\n' +
        '    /// @inheritdoc IERC20\n' +
        '    function allowance(address owner, address spender) public view virtual returns (uint256) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._allowances[owner][spender];\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev See {IERC20-approve}.\n' +
        '     *\n' +
        '     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n' +
        '     * `transferFrom`. This is semantically equivalent to an infinite approval.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `spender` cannot be the zero address.\n' +
        '     */\n' +
        '    function approve(address spender, uint256 value) public virtual returns (bool) {\n' +
        '        address owner = _msgSender();\n' +
        '        _approve(owner, spender, value);\n' +
        '        return true;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev See {IERC20-transferFrom}.\n' +
        '     *\n' +
        '     * Skips emitting an {Approval} event indicating an allowance update. This is not\n' +
        '     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n' +
        '     *\n' +
        '     * NOTE: Does not update the allowance if the current allowance\n' +
        '     * is the maximum `uint256`.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `from` and `to` cannot be the zero address.\n' +
        '     * - `from` must have a balance of at least `value`.\n' +
        "     * - the caller must have allowance for ``from``'s tokens of at least\n" +
        '     * `value`.\n' +
        '     */\n' +
        '    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n' +
        '        address spender = _msgSender();\n' +
        '        _spendAllowance(from, spender, value);\n' +
        '        _transfer(from, to, value);\n' +
        '        return true;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Moves a `value` amount of tokens from `from` to `to`.\n' +
        '     *\n' +
        '     * This internal function is equivalent to {transfer}, and can be used to\n' +
        '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     *\n' +
        '     * NOTE: This function is not virtual, {_update} should be overridden instead.\n' +
        '     */\n' +
        '    function _transfer(address from, address to, uint256 value) internal {\n' +
        '        if (from == address(0)) {\n' +
        '            revert ERC20InvalidSender(address(0));\n' +
        '        }\n' +
        '        if (to == address(0)) {\n' +
        '            revert ERC20InvalidReceiver(address(0));\n' +
        '        }\n' +
        '        _update(from, to, value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n' +
        '     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n' +
        '     * this function.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     */\n' +
        '    function _update(address from, address to, uint256 value) internal virtual {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        if (from == address(0)) {\n' +
        '            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n' +
        '            $._totalSupply += value;\n' +
        '        } else {\n' +
        '            uint256 fromBalance = $._balances[from];\n' +
        '            if (fromBalance < value) {\n' +
        '                revert ERC20InsufficientBalance(from, fromBalance, value);\n' +
        '            }\n' +
        '            unchecked {\n' +
        '                // Overflow not possible: value <= fromBalance <= totalSupply.\n' +
        '                $._balances[from] = fromBalance - value;\n' +
        '            }\n' +
        '        }\n' +
        '\n' +
        '        if (to == address(0)) {\n' +
        '            unchecked {\n' +
        '                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n' +
        '                $._totalSupply -= value;\n' +
        '            }\n' +
        '        } else {\n' +
        '            unchecked {\n' +
        '                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n' +
        '                $._balances[to] += value;\n' +
        '            }\n' +
        '        }\n' +
        '\n' +
        '        emit Transfer(from, to, value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n' +
        '     * Relies on the `_update` mechanism\n' +
        '     *\n' +
        '     * Emits a {Transfer} event with `from` set to the zero address.\n' +
        '     *\n' +
        '     * NOTE: This function is not virtual, {_update} should be overridden instead.\n' +
        '     */\n' +
        '    function _mint(address account, uint256 value) internal {\n' +
        '        if (account == address(0)) {\n' +
        '            revert ERC20InvalidReceiver(address(0));\n' +
        '        }\n' +
        '        _update(address(0), account, value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n' +
        '     * Relies on the `_update` mechanism.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event with `to` set to the zero address.\n' +
        '     *\n' +
        '     * NOTE: This function is not virtual, {_update} should be overridden instead\n' +
        '     */\n' +
        '    function _burn(address account, uint256 value) internal {\n' +
        '        if (account == address(0)) {\n' +
        '            revert ERC20InvalidSender(address(0));\n' +
        '        }\n' +
        '        _update(account, address(0), value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        "     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n" +
        '     *\n' +
        '     * This internal function is equivalent to `approve`, and can be used to\n' +
        '     * e.g. set automatic allowances for certain subsystems, etc.\n' +
        '     *\n' +
        '     * Emits an {Approval} event.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `owner` cannot be the zero address.\n' +
        '     * - `spender` cannot be the zero address.\n' +
        '     *\n' +
        '     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n' +
        '     */\n' +
        '    function _approve(address owner, address spender, uint256 value) internal {\n' +
        '        _approve(ow'... 2128 more characters
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Pausable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {ERC20Upgradeable} from "../ERC20Upgradeable.sol";\n' +
        'import {PausableUpgradeable} from "../../../utils/PausableUpgradeable.sol";\n' +
        'import {Initializable} from "../../../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev ERC-20 token with pausable token transfers, minting and burning.\n' +
        ' *\n' +
        ' * Useful for scenarios such as preventing trades until the end of an evaluation\n' +
        ' * period, or having an emergency switch for freezing all token transfers in the\n' +
        ' * event of a large bug.\n' +
        ' *\n' +
        ' * IMPORTANT: This contract does not include public pause and unpause functions. In\n' +
        ' * addition to inheriting this contract, you must define both functions, invoking the\n' +
        ' * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n' +
        ' * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n' +
        ' * make the contract pause mechanism of the contract unreachable, and thus unusable.\n' +
        ' */\n' +
        'abstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n' +
        '    function __ERC20Pausable_init() internal onlyInitializing {\n' +
        '    }\n' +
        '\n' +
        '    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n' +
        '    }\n' +
        '    /**\n' +
        '     * @dev See {ERC20-_update}.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - the contract must not be paused.\n' +
        '     */\n' +
        '    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n' +
        '        super._update(from, to, value);\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        'import {Initializable} from "../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Provides information about the current execution context, including the\n' +
        ' * sender of the transaction and its data. While these are generally available\n' +
        ' * via msg.sender and msg.data, they should not be accessed in such a direct\n' +
        ' * manner, since when dealing with meta-transactions the account sending and\n' +
        ' * paying for execution may not be the actual sender (as far as an application\n' +
        ' * is concerned).\n' +
        ' *\n' +
        ' * This contract is only required for intermediate, library-like contracts.\n' +
        ' */\n' +
        'abstract contract ContextUpgradeable is Initializable {\n' +
        '    function __Context_init() internal onlyInitializing {\n' +
        '    }\n' +
        '\n' +
        '    function __Context_init_unchained() internal onlyInitializing {\n' +
        '    }\n' +
        '    function _msgSender() internal view virtual returns (address) {\n' +
        '        return msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    function _msgData() internal view virtual returns (bytes calldata) {\n' +
        '        return msg.data;\n' +
        '    }\n' +
        '\n' +
        '    function _contextSuffixLength() internal view virtual returns (uint256) {\n' +
        '        return 0;\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";\n' +
        'import {Initializable} from "../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Contract module which allows children to implement an emergency stop\n' +
        ' * mechanism that can be triggered by an authorized account.\n' +
        ' *\n' +
        ' * This module is used through inheritance. It will make available the\n' +
        ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n' +
        ' * the functions of your contract. Note that they will not be pausable by\n' +
        ' * simply including this module, only once the modifiers are put in place.\n' +
        ' */\n' +
        'abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n' +
        '    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n' +
        '    struct PausableStorage {\n' +
        '        bool _paused;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n' +
        '\n' +
        '    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n' +
        '        assembly {\n' +
        '            $.slot := PausableStorageLocation\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Emitted when the pause is triggered by `account`.\n' +
        '     */\n' +
        '    event Paused(address account);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Emitted when the pause is lifted by `account`.\n' +
        '     */\n' +
        '    event Unpaused(address account);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The operation failed because the contract is paused.\n' +
        '     */\n' +
        '    error EnforcedPause();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The operation failed because the contract is not paused.\n' +
        '     */\n' +
        '    error ExpectedPause();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to make a function callable only when the contract is not paused.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must not be paused.\n' +
        '     */\n' +
        '    modifier whenNotPaused() {\n' +
        '        _requireNotPaused();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to make a function callable only when the contract is paused.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must be paused.\n' +
        '     */\n' +
        '    modifier whenPaused() {\n' +
        '        _requirePaused();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    function __Pausable_init() internal onlyInitializing {\n' +
        '    }\n' +
        '\n' +
        '    function __Pausable_init_unchained() internal onlyInitializing {\n' +
        '    }\n' +
        '    /**\n' +
        '     * @dev Returns true if the contract is paused, and false otherwise.\n' +
        '     */\n' +
        '    function paused() public view virtual returns (bool) {\n' +
        '        PausableStorage storage $ = _getPausableStorage();\n' +
        '        return $._paused;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if the contract is paused.\n' +
        '     */\n' +
        '    function _requireNotPaused() internal view virtual {\n' +
        '        if (paused()) {\n' +
        '            revert EnforcedPause();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if the contract is not paused.\n' +
        '     */\n' +
        '    function _requirePaused() internal view virtual {\n' +
        '        if (!paused()) {\n' +
        '            revert ExpectedPause();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggers stopped state.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must not be paused.\n' +
        '     */\n' +
        '    function _pause() internal virtual whenNotPaused {\n' +
        '        PausableStorage storage $ = _getPausableStorage();\n' +
        '        $._paused = true;\n' +
        '        emit Paused(_msgSender());\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns to normal state.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must be paused.\n' +
        '     */\n' +
        '    function _unpause() internal virtual whenPaused {\n' +
        '        PausableStorage storage $ = _getPausableStorage();\n' +
        '        $._paused = false;\n' +
        '        emit Unpaused(_msgSender());\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts/interfaces/draft-IERC6093.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\n' +
        'pragma solidity >=0.8.4;\n' +
        '\n' +
        '/**\n' +
        ' * @dev Standard ERC-20 Errors\n' +
        ' * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n' +
        ' */\n' +
        'interface IERC20Errors {\n' +
        '    /**\n' +
        '     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     * @param balance Current balance for the interacting account.\n' +
        '     * @param needed Minimum amount required to perform a transfer.\n' +
        '     */\n' +
        '    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC20InvalidSender(address sender);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n' +
        '     * @param receiver Address to which tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC20InvalidReceiver(address receiver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n' +
        '     * @param spender Address that may be allowed to operate on tokens without being their owner.\n' +
        '     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n' +
        '     * @param needed Minimum amount required to perform a transfer.\n' +
        '     */\n' +
        '    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n' +
        '     * @param approver Address initiating an approval operation.\n' +
        '     */\n' +
        '    error ERC20InvalidApprover(address approver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n' +
        '     * @param spender Address that may be allowed to operate on tokens without being their owner.\n' +
        '     */\n' +
        '    error ERC20InvalidSpender(address spender);\n' +
        '}\n' +
        '\n' +
        '/**\n' +
        ' * @dev Standard ERC-721 Errors\n' +
        ' * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n' +
        ' */\n' +
        'interface IERC721Errors {\n' +
        '    /**\n' +
        "     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n" +
        '     * Used in balance queries.\n' +
        '     * @param owner Address of the current owner of a token.\n' +
        '     */\n' +
        '    error ERC721InvalidOwner(address owner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     */\n' +
        '    error ERC721NonexistentToken(uint256 tokenId);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     * @param owner Address of the current owner of a token.\n' +
        '     */\n' +
        '    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC721InvalidSender(address sender);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n' +
        '     * @param receiver Address to which tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC721InvalidReceiver(address receiver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     */\n' +
        '    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n' +
        '     * @param approver Address initiating an approval operation.\n' +
        '     */\n' +
        '    error ERC721InvalidApprover(address approver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     */\n' +
        '    error ERC721InvalidOperator(address operator);\n' +
        '}\n' +
        '\n' +
        '/**\n' +
        ' * @dev Standard ERC-1155 Errors\n' +
        ' * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n' +
        ' */\n' +
        'interface IERC1155Errors {\n' +
        '    /**\n' +
        '     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     * @param balance Current balance for the interacting account.\n' +
        '     * @param needed Minimum amount required to perform a transfer.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     */\n' +
        '    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC1155InvalidSender(address sender);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n' +
        '     * @param receiver Address to which tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC1155InvalidReceiver(address receiver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     * @param owner Address of the current owner of a token.\n' +
        '     */\n' +
        '    error ERC1155MissingApprovalForAll(address operator, address owner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n' +
        '     * @param approver Address initiating an approval operation.\n' +
        '     */\n' +
        '    error ERC1155InvalidApprover(address approver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     */\n' +
        '    error ERC1155InvalidOperator(address operator);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n' +
        '     * Used in batch transfers.\n' +
        '     * @param idsLength Length of the array of token identifiers\n' +
        '     * @param valuesLength Length of the array of token amounts\n' +
        '     */\n' +
        '    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n' +
        '\n' +
        'pragma solidity >=0.6.2;\n' +
        '\n' +
        'import {IERC20} from "../IERC20.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Interface for the optional metadata functions from the ERC-20 standard.\n' +
        ' */\n' +
        'interface IERC20Metadata is IERC20 {\n' +
        '    /**\n' +
        '     * @dev Returns the name of the token.\n' +
        '     */\n' +
        '    function name() external view returns (string memory);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the symbol of the token.\n' +
        '     */\n' +
        '    function symbol() external view returns (string memory);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the decimals places of the token.\n' +
        '     */\n' +
        '    function decimals() external view returns (uint8);\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts/token/ERC20/IERC20.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n' +
        '\n' +
        'pragma solidity >=0.4.16;\n' +
        '\n' +
        '/**\n' +
        ' * @dev Interface of the ERC-20 standard as defined in the ERC.\n' +
        ' */\n' +
        'interface IERC20 {\n' +
        '    /**\n' +
        '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n' +
        '     * another (`to`).\n' +
        '     *\n' +
        '     * Note that `value` may be zero.\n' +
        '     */\n' +
        '    event Transfer(address indexed from, address indexed to, uint256 value);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n' +
        '     * a call to {approve}. `value` is the new allowance.\n' +
        '     */\n' +
        '    event Approval(address indexed owner, address indexed spender, uint256 value);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the value of tokens in existence.\n' +
        '     */\n' +
        '    function totalSupply() external view returns (uint256);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the value of tokens owned by `account`.\n' +
        '     */\n' +
        '    function balanceOf(address account) external view returns (uint256);\n' +
        '\n' +
        '    /**\n' +
        "     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n" +
        '     *\n' +
        '     * Returns a boolean value indicating whether the operation succeeded.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     */\n' +
        '    function transfer(address to, uint256 value) external returns (bool);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the remaining number of tokens that `spender` will be\n' +
        '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n' +
        '     * zero by default.\n' +
        '     *\n' +
        '     * This value changes when {approve} or {transferFrom} are called.\n' +
        '     */\n' +
        '    function allowance(address owner, address spender) external view returns (uint256);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n' +
        "     * caller's tokens.\n" +
        '     *\n' +
        '     * Returns a boolean value indicating whether the operation succeeded.\n' +
        '     *\n' +
        '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n' +
        '     * that someone may use both the old and the new allowance by unfortunate\n' +
        '     * transaction ordering. One possible solution to mitigate this race\n' +
        "     * condition is to first reduce the spender's allowance to 0 and set the\n" +
        '     * desired value afterwards:\n' +
        '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n' +
        '     *\n' +
        '     * Emits an {Approval} event.\n' +
        '     */\n' +
        '    function approve(address spender, uint256 value) external returns (bool);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n' +
        "     * allowance mechanism. `value` is then deducted from the caller's\n" +
        '     * allowance.\n' +
        '     *\n' +
        '     * Returns a boolean value indicating whether the operation succeeded.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     */\n' +
        '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n' +
        '}\n'
    },
    {
      filePath: 'contracts/GoldTokenV2.sol',
      sourceCode: '// contracts/GoldTokenV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol";\n' +
        '\n' +
        '// PENTING: Ganti pewarisan dengan ERC20PausableUpgradeable\n' +
        'contract GoldTokenV2 is Initializable, ERC20Upgradeable, OwnableUpgradeable, ERC20PausableUpgradeable {\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    function initialize(uint256 _initialSupply) public initializer {\n' +
        '        __ERC20_init("Gold Token", "GLD");\n' +
        '        __Ownable_init(msg.sender);\n' +
        '        __ERC20Pausable_init(); // Gunakan initializer dari ERC20Pausable\n' +
        '\n' +
        '        if (_initialSupply > 0) {\n' +
        '            _mint(msg.sender, _initialSupply * 10**18);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    function mint(address to, uint256 amount) external onlyOwner {\n' +
        '        _mint(to, amount);\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi pause dan unpause sekarang menjadi bagian dari ERC20Pausable\n' +
        '    function pause() public onlyOwner {\n' +
        '        _pause();\n' +
        '    }\n' +
        '\n' +
        '    function unpause() public onlyOwner {\n' +
        '        _unpause();\n' +
        '    }\n' +
        '    \n' +
        '    // ===================================================================\n' +
        '    // ## INI PERUBAHAN UTAMANYA ##\n' +
        '    // Kita override _update, bukan _beforeTokenTransfer.\n' +
        '    // `super._update` akan secara otomatis menjalankan pengecekan `whenNotPaused`.\n' +
        '    // ===================================================================\n' +
        '    function _update(address from, address to, uint256 value)\n' +
        '        internal\n' +
        '        override(ERC20Upgradeable, ERC20PausableUpgradeable)\n' +
        '    {\n' +
        '        super._update(from, to, value);\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-12-25 17:47:45.007 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xF12b5dd4EAD5F743C6BaA640B0216200e89B60Da',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0xfb467656fa29b7626ed42d656036b66748adbc417ea1f7646f901baf7b7ffaf4',
  isVerified: true,
  sourceFiles: [
    {
      filePath: '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";\n' +
        'import {Initializable} from "../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Contract module which provides a basic access control mechanism, where\n' +
        ' * there is an account (an owner) that can be granted exclusive access to\n' +
        ' * specific functions.\n' +
        ' *\n' +
        ' * The initial owner is set to the address provided by the deployer. This can\n' +
        ' * later be changed with {transferOwnership}.\n' +
        ' *\n' +
        ' * This module is used through inheritance. It will make available the modifier\n' +
        ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n' +
        ' * the owner.\n' +
        ' */\n' +
        'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n' +
        '    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n' +
        '    struct OwnableStorage {\n' +
        '        address _owner;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Ownable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n' +
        '\n' +
        '    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n' +
        '        assembly {\n' +
        '            $.slot := OwnableStorageLocation\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The caller account is not authorized to perform an operation.\n' +
        '     */\n' +
        '    error OwnableUnauthorizedAccount(address account);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n' +
        '     */\n' +
        '    error OwnableInvalidOwner(address owner);\n' +
        '\n' +
        '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n' +
        '     */\n' +
        '    function __Ownable_init(address initialOwner) internal onlyInitializing {\n' +
        '        __Ownable_init_unchained(initialOwner);\n' +
        '    }\n' +
        '\n' +
        '    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n' +
        '        if (initialOwner == address(0)) {\n' +
        '            revert OwnableInvalidOwner(address(0));\n' +
        '        }\n' +
        '        _transferOwnership(initialOwner);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if called by any account other than the owner.\n' +
        '     */\n' +
        '    modifier onlyOwner() {\n' +
        '        _checkOwner();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the address of the current owner.\n' +
        '     */\n' +
        '    function owner() public view virtual returns (address) {\n' +
        '        OwnableStorage storage $ = _getOwnableStorage();\n' +
        '        return $._owner;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if the sender is not the owner.\n' +
        '     */\n' +
        '    function _checkOwner() internal view virtual {\n' +
        '        if (owner() != _msgSender()) {\n' +
        '            revert OwnableUnauthorizedAccount(_msgSender());\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Leaves the contract without owner. It will not be possible to call\n' +
        '     * `onlyOwner` functions. Can only be called by the current owner.\n' +
        '     *\n' +
        '     * NOTE: Renouncing ownership will leave the contract without an owner,\n' +
        '     * thereby disabling any functionality that is only available to the owner.\n' +
        '     */\n' +
        '    function renounceOwnership() public virtual onlyOwner {\n' +
        '        _transferOwnership(address(0));\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n' +
        '     * Can only be called by the current owner.\n' +
        '     */\n' +
        '    function transferOwnership(address newOwner) public virtual onlyOwner {\n' +
        '        if (newOwner == address(0)) {\n' +
        '            revert OwnableInvalidOwner(address(0));\n' +
        '        }\n' +
        '        _transferOwnership(newOwner);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n' +
        '     * Internal function without access restriction.\n' +
        '     */\n' +
        '    function _transferOwnership(address newOwner) internal virtual {\n' +
        '        OwnableStorage storage $ = _getOwnableStorage();\n' +
        '        address oldOwner = $._owner;\n' +
        '        $._owner = newOwner;\n' +
        '        emit OwnershipTransferred(oldOwner, newOwner);\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        '/**\n' +
        ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n' +
        " * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n" +
        ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n' +
        ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n' +
        ' *\n' +
        ' * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n' +
        ' * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in\n' +
        ' * case an upgrade adds a module that needs to be initialized.\n' +
        ' *\n' +
        ' * For example:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```solidity\n' +
        ' * contract MyToken is ERC20Upgradeable {\n' +
        ' *     function initialize() initializer public {\n' +
        ' *         __ERC20_init("MyToken", "MTK");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' *\n' +
        ' * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n' +
        ' *     function initializeV2() reinitializer(2) public {\n' +
        ' *         __ERC20Permit_init("MyToken");\n' +
        ' *     }\n' +
        ' * }\n' +
        ' * ```\n' +
        ' *\n' +
        ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n' +
        ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n' +
        ' *\n' +
        ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n' +
        ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n' +
        ' *\n' +
        ' * [CAUTION]\n' +
        ' * ====\n' +
        ' * Avoid leaving a contract uninitialized.\n' +
        ' *\n' +
        ' * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n' +
        ' * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n' +
        ' * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n' +
        ' *\n' +
        ' * [.hljs-theme-light.nopadding]\n' +
        ' * ```\n' +
        ' * /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        ' * constructor() {\n' +
        ' *     _disableInitializers();\n' +
        ' * }\n' +
        ' * ```\n' +
        ' * ====\n' +
        ' */\n' +
        'abstract contract Initializable {\n' +
        '    /**\n' +
        '     * @dev Storage of the initializable contract.\n' +
        '     *\n' +
        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n" +
        '     * when using with upgradeable contracts.\n' +
        '     *\n' +
        '     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n' +
        '     */\n' +
        '    struct InitializableStorage {\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract has been initialized.\n' +
        '         */\n' +
        '        uint64 _initialized;\n' +
        '        /**\n' +
        '         * @dev Indicates that the contract is in the process of being initialized.\n' +
        '         */\n' +
        '        bool _initializing;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is already initialized.\n' +
        '     */\n' +
        '    error InvalidInitialization();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The contract is not initializing.\n' +
        '     */\n' +
        '    error NotInitializing();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggered when the contract has been initialized or reinitialized.\n' +
        '     */\n' +
        '    event Initialized(uint64 version);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n' +
        '     * `onlyInitializing` functions can be used to initialize parent contracts.\n' +
        '     *\n' +
        '     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n' +
        '     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n' +
        '     * production.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier initializer() {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        // Cache values to avoid duplicated sloads\n' +
        '        bool isTopLevelCall = !$._initializing;\n' +
        '        uint64 initialized = $._initialized;\n' +
        '\n' +
        '        // Allowed calls:\n' +
        '        // - initialSetup: the contract is not in the initializing state and no previous version was\n' +
        '        //                 initialized\n' +
        '        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n' +
        '        //                 current contract is just being deployed\n' +
        '        bool initialSetup = initialized == 0 && isTopLevelCall;\n' +
        '        bool construction = initialized == 1 && address(this).code.length == 0;\n' +
        '\n' +
        '        if (!initialSetup && !construction) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = 1;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = true;\n' +
        '        }\n' +
        '        _;\n' +
        '        if (isTopLevelCall) {\n' +
        '            $._initializing = false;\n' +
        '            emit Initialized(1);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n' +
        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n" +
        '     * used to initialize parent contracts.\n' +
        '     *\n' +
        '     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n' +
        '     * are added through upgrades and that require initialization.\n' +
        '     *\n' +
        '     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n' +
        '     * cannot be nested. If one is invoked in the context of another, execution will revert.\n' +
        '     *\n' +
        '     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n' +
        '     * a contract, executing them in the right order is up to the developer or operator.\n' +
        '     *\n' +
        '     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event.\n' +
        '     */\n' +
        '    modifier reinitializer(uint64 version) {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing || $._initialized >= version) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        $._initialized = version;\n' +
        '        $._initializing = true;\n' +
        '        _;\n' +
        '        $._initializing = false;\n' +
        '        emit Initialized(version);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n' +
        '     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n' +
        '     */\n' +
        '    modifier onlyInitializing() {\n' +
        '        _checkInitializing();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _checkInitializing() internal view virtual {\n' +
        '        if (!_isInitializing()) {\n' +
        '            revert NotInitializing();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n' +
        '     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n' +
        '     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n' +
        '     * through proxies.\n' +
        '     *\n' +
        '     * Emits an {Initialized} event the first time it is successfully executed.\n' +
        '     */\n' +
        '    function _disableInitializers() internal virtual {\n' +
        '        // solhint-disable-next-line var-name-mixedcase\n' +
        '        InitializableStorage storage $ = _getInitializableStorage();\n' +
        '\n' +
        '        if ($._initializing) {\n' +
        '            revert InvalidInitialization();\n' +
        '        }\n' +
        '        if ($._initialized != type(uint64).max) {\n' +
        '            $._initialized = type(uint64).max;\n' +
        '            emit Initialized(type(uint64).max);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n' +
        '     */\n' +
        '    function _getInitializedVersion() internal view returns (uint64) {\n' +
        '        return _getInitializableStorage()._initialized;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n' +
        '     */\n' +
        '    function _isInitializing() internal view returns (bool) {\n' +
        '        return _getInitializableStorage()._initializing;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n' +
        '     *\n' +
        '     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n' +
        '     */\n' +
        '    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n' +
        '        return INITIALIZABLE_STORAGE;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns a pointer to the storage namespace.\n' +
        '     */\n' +
        '    // solhint-disable-next-line var-name-mixedcase\n' +
        '    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n' +
        '        bytes32 slot = _initializableStorageSlot();\n' +
        '        assembly {\n' +
        '            $.slot := slot\n' +
        '        }\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n' +
        'import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";\n' +
        'import {ContextUpgradeable} from "../../utils/ContextUpgradeable.sol";\n' +
        'import {IERC20Errors} from "@openzeppelin/contracts/interfaces/draft-IERC6093.sol";\n' +
        'import {Initializable} from "../../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Implementation of the {IERC20} interface.\n' +
        ' *\n' +
        ' * This implementation is agnostic to the way tokens are created. This means\n' +
        ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n' +
        ' *\n' +
        ' * TIP: For a detailed writeup see our guide\n' +
        ' * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n' +
        ' * to implement supply mechanisms].\n' +
        ' *\n' +
        ' * The default value of {decimals} is 18. To change this, you should override\n' +
        ' * this function so it returns a different value.\n' +
        ' *\n' +
        ' * We have followed general OpenZeppelin Contracts guidelines: functions revert\n' +
        ' * instead returning `false` on failure. This behavior is nonetheless\n' +
        ' * conventional and does not conflict with the expectations of ERC-20\n' +
        ' * applications.\n' +
        ' */\n' +
        'abstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n' +
        '    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n' +
        '    struct ERC20Storage {\n' +
        '        mapping(address account => uint256) _balances;\n' +
        '\n' +
        '        mapping(address account => mapping(address spender => uint256)) _allowances;\n' +
        '\n' +
        '        uint256 _totalSupply;\n' +
        '\n' +
        '        string _name;\n' +
        '        string _symbol;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ERC20")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n' +
        '\n' +
        '    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n' +
        '        assembly {\n' +
        '            $.slot := ERC20StorageLocation\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Sets the values for {name} and {symbol}.\n' +
        '     *\n' +
        '     * Both values are immutable: they can only be set once during construction.\n' +
        '     */\n' +
        '    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n' +
        '        __ERC20_init_unchained(name_, symbol_);\n' +
        '    }\n' +
        '\n' +
        '    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        $._name = name_;\n' +
        '        $._symbol = symbol_;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the name of the token.\n' +
        '     */\n' +
        '    function name() public view virtual returns (string memory) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._name;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the symbol of the token, usually a shorter version of the\n' +
        '     * name.\n' +
        '     */\n' +
        '    function symbol() public view virtual returns (string memory) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._symbol;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the number of decimals used to get its user representation.\n' +
        '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n' +
        '     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n' +
        '     *\n' +
        '     * Tokens usually opt for a value of 18, imitating the relationship between\n' +
        '     * Ether and Wei. This is the default value returned by this function, unless\n' +
        "     * it's overridden.\n" +
        '     *\n' +
        '     * NOTE: This information is only used for _display_ purposes: it in\n' +
        '     * no way affects any of the arithmetic of the contract, including\n' +
        '     * {IERC20-balanceOf} and {IERC20-transfer}.\n' +
        '     */\n' +
        '    function decimals() public view virtual returns (uint8) {\n' +
        '        return 18;\n' +
        '    }\n' +
        '\n' +
        '    /// @inheritdoc IERC20\n' +
        '    function totalSupply() public view virtual returns (uint256) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._totalSupply;\n' +
        '    }\n' +
        '\n' +
        '    /// @inheritdoc IERC20\n' +
        '    function balanceOf(address account) public view virtual returns (uint256) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._balances[account];\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev See {IERC20-transfer}.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `to` cannot be the zero address.\n' +
        '     * - the caller must have a balance of at least `value`.\n' +
        '     */\n' +
        '    function transfer(address to, uint256 value) public virtual returns (bool) {\n' +
        '        address owner = _msgSender();\n' +
        '        _transfer(owner, to, value);\n' +
        '        return true;\n' +
        '    }\n' +
        '\n' +
        '    /// @inheritdoc IERC20\n' +
        '    function allowance(address owner, address spender) public view virtual returns (uint256) {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        return $._allowances[owner][spender];\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev See {IERC20-approve}.\n' +
        '     *\n' +
        '     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n' +
        '     * `transferFrom`. This is semantically equivalent to an infinite approval.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `spender` cannot be the zero address.\n' +
        '     */\n' +
        '    function approve(address spender, uint256 value) public virtual returns (bool) {\n' +
        '        address owner = _msgSender();\n' +
        '        _approve(owner, spender, value);\n' +
        '        return true;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev See {IERC20-transferFrom}.\n' +
        '     *\n' +
        '     * Skips emitting an {Approval} event indicating an allowance update. This is not\n' +
        '     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n' +
        '     *\n' +
        '     * NOTE: Does not update the allowance if the current allowance\n' +
        '     * is the maximum `uint256`.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `from` and `to` cannot be the zero address.\n' +
        '     * - `from` must have a balance of at least `value`.\n' +
        "     * - the caller must have allowance for ``from``'s tokens of at least\n" +
        '     * `value`.\n' +
        '     */\n' +
        '    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n' +
        '        address spender = _msgSender();\n' +
        '        _spendAllowance(from, spender, value);\n' +
        '        _transfer(from, to, value);\n' +
        '        return true;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Moves a `value` amount of tokens from `from` to `to`.\n' +
        '     *\n' +
        '     * This internal function is equivalent to {transfer}, and can be used to\n' +
        '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     *\n' +
        '     * NOTE: This function is not virtual, {_update} should be overridden instead.\n' +
        '     */\n' +
        '    function _transfer(address from, address to, uint256 value) internal {\n' +
        '        if (from == address(0)) {\n' +
        '            revert ERC20InvalidSender(address(0));\n' +
        '        }\n' +
        '        if (to == address(0)) {\n' +
        '            revert ERC20InvalidReceiver(address(0));\n' +
        '        }\n' +
        '        _update(from, to, value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n' +
        '     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n' +
        '     * this function.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     */\n' +
        '    function _update(address from, address to, uint256 value) internal virtual {\n' +
        '        ERC20Storage storage $ = _getERC20Storage();\n' +
        '        if (from == address(0)) {\n' +
        '            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n' +
        '            $._totalSupply += value;\n' +
        '        } else {\n' +
        '            uint256 fromBalance = $._balances[from];\n' +
        '            if (fromBalance < value) {\n' +
        '                revert ERC20InsufficientBalance(from, fromBalance, value);\n' +
        '            }\n' +
        '            unchecked {\n' +
        '                // Overflow not possible: value <= fromBalance <= totalSupply.\n' +
        '                $._balances[from] = fromBalance - value;\n' +
        '            }\n' +
        '        }\n' +
        '\n' +
        '        if (to == address(0)) {\n' +
        '            unchecked {\n' +
        '                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n' +
        '                $._totalSupply -= value;\n' +
        '            }\n' +
        '        } else {\n' +
        '            unchecked {\n' +
        '                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n' +
        '                $._balances[to] += value;\n' +
        '            }\n' +
        '        }\n' +
        '\n' +
        '        emit Transfer(from, to, value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n' +
        '     * Relies on the `_update` mechanism\n' +
        '     *\n' +
        '     * Emits a {Transfer} event with `from` set to the zero address.\n' +
        '     *\n' +
        '     * NOTE: This function is not virtual, {_update} should be overridden instead.\n' +
        '     */\n' +
        '    function _mint(address account, uint256 value) internal {\n' +
        '        if (account == address(0)) {\n' +
        '            revert ERC20InvalidReceiver(address(0));\n' +
        '        }\n' +
        '        _update(address(0), account, value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n' +
        '     * Relies on the `_update` mechanism.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event with `to` set to the zero address.\n' +
        '     *\n' +
        '     * NOTE: This function is not virtual, {_update} should be overridden instead\n' +
        '     */\n' +
        '    function _burn(address account, uint256 value) internal {\n' +
        '        if (account == address(0)) {\n' +
        '            revert ERC20InvalidSender(address(0));\n' +
        '        }\n' +
        '        _update(account, address(0), value);\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        "     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n" +
        '     *\n' +
        '     * This internal function is equivalent to `approve`, and can be used to\n' +
        '     * e.g. set automatic allowances for certain subsystems, etc.\n' +
        '     *\n' +
        '     * Emits an {Approval} event.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - `owner` cannot be the zero address.\n' +
        '     * - `spender` cannot be the zero address.\n' +
        '     *\n' +
        '     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n' +
        '     */\n' +
        '    function _approve(address owner, address spender, uint256 value) internal {\n' +
        '        _approve(ow'... 2128 more characters
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/ERC20Pausable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {ERC20Upgradeable} from "../ERC20Upgradeable.sol";\n' +
        'import {PausableUpgradeable} from "../../../utils/PausableUpgradeable.sol";\n' +
        'import {Initializable} from "../../../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev ERC-20 token with pausable token transfers, minting and burning.\n' +
        ' *\n' +
        ' * Useful for scenarios such as preventing trades until the end of an evaluation\n' +
        ' * period, or having an emergency switch for freezing all token transfers in the\n' +
        ' * event of a large bug.\n' +
        ' *\n' +
        ' * IMPORTANT: This contract does not include public pause and unpause functions. In\n' +
        ' * addition to inheriting this contract, you must define both functions, invoking the\n' +
        ' * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n' +
        ' * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n' +
        ' * make the contract pause mechanism of the contract unreachable, and thus unusable.\n' +
        ' */\n' +
        'abstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n' +
        '    function __ERC20Pausable_init() internal onlyInitializing {\n' +
        '    }\n' +
        '\n' +
        '    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n' +
        '    }\n' +
        '    /**\n' +
        '     * @dev See {ERC20-_update}.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - the contract must not be paused.\n' +
        '     */\n' +
        '    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n' +
        '        super._update(from, to, value);\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        'import {Initializable} from "../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Provides information about the current execution context, including the\n' +
        ' * sender of the transaction and its data. While these are generally available\n' +
        ' * via msg.sender and msg.data, they should not be accessed in such a direct\n' +
        ' * manner, since when dealing with meta-transactions the account sending and\n' +
        ' * paying for execution may not be the actual sender (as far as an application\n' +
        ' * is concerned).\n' +
        ' *\n' +
        ' * This contract is only required for intermediate, library-like contracts.\n' +
        ' */\n' +
        'abstract contract ContextUpgradeable is Initializable {\n' +
        '    function __Context_init() internal onlyInitializing {\n' +
        '    }\n' +
        '\n' +
        '    function __Context_init_unchained() internal onlyInitializing {\n' +
        '    }\n' +
        '    function _msgSender() internal view virtual returns (address) {\n' +
        '        return msg.sender;\n' +
        '    }\n' +
        '\n' +
        '    function _msgData() internal view virtual returns (bytes calldata) {\n' +
        '        return msg.data;\n' +
        '    }\n' +
        '\n' +
        '    function _contextSuffixLength() internal view virtual returns (uint256) {\n' +
        '        return 0;\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n' +
        '\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";\n' +
        'import {Initializable} from "../proxy/utils/Initializable.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Contract module which allows children to implement an emergency stop\n' +
        ' * mechanism that can be triggered by an authorized account.\n' +
        ' *\n' +
        ' * This module is used through inheritance. It will make available the\n' +
        ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n' +
        ' * the functions of your contract. Note that they will not be pausable by\n' +
        ' * simply including this module, only once the modifiers are put in place.\n' +
        ' */\n' +
        'abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n' +
        '    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n' +
        '    struct PausableStorage {\n' +
        '        bool _paused;\n' +
        '    }\n' +
        '\n' +
        '    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))\n' +
        '    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n' +
        '\n' +
        '    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n' +
        '        assembly {\n' +
        '            $.slot := PausableStorageLocation\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Emitted when the pause is triggered by `account`.\n' +
        '     */\n' +
        '    event Paused(address account);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Emitted when the pause is lifted by `account`.\n' +
        '     */\n' +
        '    event Unpaused(address account);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The operation failed because the contract is paused.\n' +
        '     */\n' +
        '    error EnforcedPause();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev The operation failed because the contract is not paused.\n' +
        '     */\n' +
        '    error ExpectedPause();\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to make a function callable only when the contract is not paused.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must not be paused.\n' +
        '     */\n' +
        '    modifier whenNotPaused() {\n' +
        '        _requireNotPaused();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Modifier to make a function callable only when the contract is paused.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must be paused.\n' +
        '     */\n' +
        '    modifier whenPaused() {\n' +
        '        _requirePaused();\n' +
        '        _;\n' +
        '    }\n' +
        '\n' +
        '    function __Pausable_init() internal onlyInitializing {\n' +
        '    }\n' +
        '\n' +
        '    function __Pausable_init_unchained() internal onlyInitializing {\n' +
        '    }\n' +
        '    /**\n' +
        '     * @dev Returns true if the contract is paused, and false otherwise.\n' +
        '     */\n' +
        '    function paused() public view virtual returns (bool) {\n' +
        '        PausableStorage storage $ = _getPausableStorage();\n' +
        '        return $._paused;\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if the contract is paused.\n' +
        '     */\n' +
        '    function _requireNotPaused() internal view virtual {\n' +
        '        if (paused()) {\n' +
        '            revert EnforcedPause();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Throws if the contract is not paused.\n' +
        '     */\n' +
        '    function _requirePaused() internal view virtual {\n' +
        '        if (!paused()) {\n' +
        '            revert ExpectedPause();\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Triggers stopped state.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must not be paused.\n' +
        '     */\n' +
        '    function _pause() internal virtual whenNotPaused {\n' +
        '        PausableStorage storage $ = _getPausableStorage();\n' +
        '        $._paused = true;\n' +
        '        emit Paused(_msgSender());\n' +
        '    }\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns to normal state.\n' +
        '     *\n' +
        '     * Requirements:\n' +
        '     *\n' +
        '     * - The contract must be paused.\n' +
        '     */\n' +
        '    function _unpause() internal virtual whenPaused {\n' +
        '        PausableStorage storage $ = _getPausableStorage();\n' +
        '        $._paused = false;\n' +
        '        emit Unpaused(_msgSender());\n' +
        '    }\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts/interfaces/draft-IERC6093.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\n' +
        'pragma solidity >=0.8.4;\n' +
        '\n' +
        '/**\n' +
        ' * @dev Standard ERC-20 Errors\n' +
        ' * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n' +
        ' */\n' +
        'interface IERC20Errors {\n' +
        '    /**\n' +
        '     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     * @param balance Current balance for the interacting account.\n' +
        '     * @param needed Minimum amount required to perform a transfer.\n' +
        '     */\n' +
        '    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC20InvalidSender(address sender);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n' +
        '     * @param receiver Address to which tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC20InvalidReceiver(address receiver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.\n' +
        '     * @param spender Address that may be allowed to operate on tokens without being their owner.\n' +
        '     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n' +
        '     * @param needed Minimum amount required to perform a transfer.\n' +
        '     */\n' +
        '    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n' +
        '     * @param approver Address initiating an approval operation.\n' +
        '     */\n' +
        '    error ERC20InvalidApprover(address approver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n' +
        '     * @param spender Address that may be allowed to operate on tokens without being their owner.\n' +
        '     */\n' +
        '    error ERC20InvalidSpender(address spender);\n' +
        '}\n' +
        '\n' +
        '/**\n' +
        ' * @dev Standard ERC-721 Errors\n' +
        ' * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n' +
        ' */\n' +
        'interface IERC721Errors {\n' +
        '    /**\n' +
        "     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n" +
        '     * Used in balance queries.\n' +
        '     * @param owner Address of the current owner of a token.\n' +
        '     */\n' +
        '    error ERC721InvalidOwner(address owner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     */\n' +
        '    error ERC721NonexistentToken(uint256 tokenId);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     * @param owner Address of the current owner of a token.\n' +
        '     */\n' +
        '    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC721InvalidSender(address sender);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n' +
        '     * @param receiver Address to which tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC721InvalidReceiver(address receiver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     */\n' +
        '    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n' +
        '     * @param approver Address initiating an approval operation.\n' +
        '     */\n' +
        '    error ERC721InvalidApprover(address approver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     */\n' +
        '    error ERC721InvalidOperator(address operator);\n' +
        '}\n' +
        '\n' +
        '/**\n' +
        ' * @dev Standard ERC-1155 Errors\n' +
        ' * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n' +
        ' */\n' +
        'interface IERC1155Errors {\n' +
        '    /**\n' +
        '     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     * @param balance Current balance for the interacting account.\n' +
        '     * @param needed Minimum amount required to perform a transfer.\n' +
        '     * @param tokenId Identifier number of a token.\n' +
        '     */\n' +
        '    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `sender`. Used in transfers.\n' +
        '     * @param sender Address whose tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC1155InvalidSender(address sender);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n' +
        '     * @param receiver Address to which tokens are being transferred.\n' +
        '     */\n' +
        '    error ERC1155InvalidReceiver(address receiver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator`s approval. Used in transfers.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     * @param owner Address of the current owner of a token.\n' +
        '     */\n' +
        '    error ERC1155MissingApprovalForAll(address operator, address owner);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n' +
        '     * @param approver Address initiating an approval operation.\n' +
        '     */\n' +
        '    error ERC1155InvalidApprover(address approver);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n' +
        '     * @param operator Address that may be allowed to operate on tokens without being their owner.\n' +
        '     */\n' +
        '    error ERC1155InvalidOperator(address operator);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n' +
        '     * Used in batch transfers.\n' +
        '     * @param idsLength Length of the array of token identifiers\n' +
        '     * @param valuesLength Length of the array of token amounts\n' +
        '     */\n' +
        '    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n' +
        '\n' +
        'pragma solidity >=0.6.2;\n' +
        '\n' +
        'import {IERC20} from "../IERC20.sol";\n' +
        '\n' +
        '/**\n' +
        ' * @dev Interface for the optional metadata functions from the ERC-20 standard.\n' +
        ' */\n' +
        'interface IERC20Metadata is IERC20 {\n' +
        '    /**\n' +
        '     * @dev Returns the name of the token.\n' +
        '     */\n' +
        '    function name() external view returns (string memory);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the symbol of the token.\n' +
        '     */\n' +
        '    function symbol() external view returns (string memory);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the decimals places of the token.\n' +
        '     */\n' +
        '    function decimals() external view returns (uint8);\n' +
        '}\n'
    },
    {
      filePath: '@openzeppelin/contracts/token/ERC20/IERC20.sol',
      sourceCode: '// SPDX-License-Identifier: MIT\n' +
        '// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n' +
        '\n' +
        'pragma solidity >=0.4.16;\n' +
        '\n' +
        '/**\n' +
        ' * @dev Interface of the ERC-20 standard as defined in the ERC.\n' +
        ' */\n' +
        'interface IERC20 {\n' +
        '    /**\n' +
        '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n' +
        '     * another (`to`).\n' +
        '     *\n' +
        '     * Note that `value` may be zero.\n' +
        '     */\n' +
        '    event Transfer(address indexed from, address indexed to, uint256 value);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n' +
        '     * a call to {approve}. `value` is the new allowance.\n' +
        '     */\n' +
        '    event Approval(address indexed owner, address indexed spender, uint256 value);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the value of tokens in existence.\n' +
        '     */\n' +
        '    function totalSupply() external view returns (uint256);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the value of tokens owned by `account`.\n' +
        '     */\n' +
        '    function balanceOf(address account) external view returns (uint256);\n' +
        '\n' +
        '    /**\n' +
        "     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n" +
        '     *\n' +
        '     * Returns a boolean value indicating whether the operation succeeded.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     */\n' +
        '    function transfer(address to, uint256 value) external returns (bool);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Returns the remaining number of tokens that `spender` will be\n' +
        '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n' +
        '     * zero by default.\n' +
        '     *\n' +
        '     * This value changes when {approve} or {transferFrom} are called.\n' +
        '     */\n' +
        '    function allowance(address owner, address spender) external view returns (uint256);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n' +
        "     * caller's tokens.\n" +
        '     *\n' +
        '     * Returns a boolean value indicating whether the operation succeeded.\n' +
        '     *\n' +
        '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n' +
        '     * that someone may use both the old and the new allowance by unfortunate\n' +
        '     * transaction ordering. One possible solution to mitigate this race\n' +
        "     * condition is to first reduce the spender's allowance to 0 and set the\n" +
        '     * desired value afterwards:\n' +
        '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n' +
        '     *\n' +
        '     * Emits an {Approval} event.\n' +
        '     */\n' +
        '    function approve(address spender, uint256 value) external returns (bool);\n' +
        '\n' +
        '    /**\n' +
        '     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n' +
        "     * allowance mechanism. `value` is then deducted from the caller's\n" +
        '     * allowance.\n' +
        '     *\n' +
        '     * Returns a boolean value indicating whether the operation succeeded.\n' +
        '     *\n' +
        '     * Emits a {Transfer} event.\n' +
        '     */\n' +
        '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n' +
        '}\n'
    },
    {
      filePath: 'contracts/GoldTokenV2.sol',
      sourceCode: '// contracts/GoldTokenV2.sol\n' +
        '\n' +
        '// SPDX-License-Identifier: MIT\n' +
        'pragma solidity ^0.8.20;\n' +
        '\n' +
        'import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\n' +
        'import "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol";\n' +
        '\n' +
        '// PENTING: Ganti pewarisan dengan ERC20PausableUpgradeable\n' +
        'contract GoldTokenV2 is Initializable, ERC20Upgradeable, OwnableUpgradeable, ERC20PausableUpgradeable {\n' +
        '    /// @custom:oz-upgrades-unsafe-allow constructor\n' +
        '    constructor() {\n' +
        '        _disableInitializers();\n' +
        '    }\n' +
        '\n' +
        '    function initialize(uint256 _initialSupply) public initializer {\n' +
        '        __ERC20_init("Gold Token", "GLD");\n' +
        '        __Ownable_init(msg.sender);\n' +
        '        __ERC20Pausable_init(); // Gunakan initializer dari ERC20Pausable\n' +
        '\n' +
        '        if (_initialSupply > 0) {\n' +
        '            _mint(msg.sender, _initialSupply * 10**18);\n' +
        '        }\n' +
        '    }\n' +
        '\n' +
        '    function mint(address to, uint256 amount) external onlyOwner {\n' +
        '        _mint(to, amount);\n' +
        '    }\n' +
        '\n' +
        '    // Fungsi pause dan unpause sekarang menjadi bagian dari ERC20Pausable\n' +
        '    function pause() public onlyOwner {\n' +
        '        _pause();\n' +
        '    }\n' +
        '\n' +
        '    function unpause() public onlyOwner {\n' +
        '        _unpause();\n' +
        '    }\n' +
        '    \n' +
        '    // ===================================================================\n' +
        '    // ## INI PERUBAHAN UTAMANYA ##\n' +
        '    // Kita override _update, bukan _beforeTokenTransfer.\n' +
        '    // `super._update` akan secara otomatis menjalankan pengecekan `whenNotPaused`.\n' +
        '    // ===================================================================\n' +
        '    function _update(address from, address to, uint256 value)\n' +
        '        internal\n' +
        '        override(ERC20Upgradeable, ERC20PausableUpgradeable)\n' +
        '    {\n' +
        '        super._update(from, to, value);\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'GoldTokenV2',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    {
      name: 'ERC20InsufficientAllowance',
      type: 'error',
      inputs: [
        { name: 'spender', type: 'address', internalType: 'address' },
        { name: 'allowance', type: 'uint256', internalType: 'uint256' },
        { name: 'needed', type: 'uint256', internalType: 'uint256' }
      ]
    },
    {
      name: 'ERC20InsufficientBalance',
      type: 'error',
      inputs: [
        { name: 'sender', type: 'address', internalType: 'address' },
        { name: 'balance', type: 'uint256', internalType: 'uint256' },
        { name: 'needed', type: 'uint256', internalType: 'uint256' }
      ]
    },
    {
      name: 'ERC20InvalidApprover',
      type: 'error',
      inputs: [
        { name: 'approver', type: 'address', internalType: 'address' }
      ]
    },
    {
      name: 'ERC20InvalidReceiver',
      type: 'error',
      inputs: [
        { name: 'receiver', type: 'address', internalType: 'address' }
      ]
    },
    {
      name: 'ERC20InvalidSender',
      type: 'error',
      inputs: [ { name: 'sender', type: 'address', internalType: 'address' } ]
    },
    {
      name: 'ERC20InvalidSpender',
      type: 'error',
      inputs: [ { name: 'spender', type: 'address', internalType: 'address' } ]
    },
    { name: 'EnforcedPause', type: 'error', inputs: [] },
    { name: 'ExpectedPause', type: 'error', inputs: [] },
    { name: 'InvalidInitialization', type: 'error', inputs: [] },
    { name: 'NotInitializing', type: 'error', inputs: [] },
    {
      name: 'OwnableInvalidOwner',
      type: 'error',
      inputs: [ { name: 'owner', type: 'address', internalType: 'address' } ]
    },
    {
      name: 'OwnableUnauthorizedAccount',
      type: 'error',
      inputs: [ { name: 'account', type: 'address', internalType: 'address' } ]
    },
    {
      name: 'Approval',
      type: 'event',
      inputs: [
        {
          name: 'owner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'spender',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'value',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'Initialized',
      type: 'event',
      inputs: [
        {
          name: 'version',
          type: 'uint64',
          indexed: false,
          internalType: 'uint64'
        }
      ],
      anonymous: false
    },
    {
      name: 'OwnershipTransferred',
      type: 'event',
      inputs: [
        {
          name: 'previousOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'newOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'Paused',
      type: 'event',
      inputs: [
        {
          name: 'account',
          type: 'address',
          indexed: false,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'Transfer',
      type: 'event',
      inputs: [
        {
          name: 'from',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'to',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'value',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'Unpaused',
      type: 'event',
      inputs: [
        {
          name: 'account',
          type: 'address',
          indexed: false,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'allowance',
      type: 'function',
      inputs: [
        { name: 'owner', type: 'address', internalType: 'address' },
        { name: 'spender', type: 'address', internalType: 'address' }
      ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'approve',
      type: 'function',
      inputs: [
        { name: 'spender', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'nonpayable'
    },
    {
      name: 'balanceOf',
      type: 'function',
      inputs: [ { name: 'account', type: 'address', internalType: 'address' } ],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'decimals',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'uint8', internalType: 'uint8' } ],
      stateMutability: 'view'
    },
    {
      name: 'initialize',
      type: 'function',
      inputs: [
        {
          name: '_initialSupply',
          type: 'uint256',
          internalType: 'uint256'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'mint',
      type: 'function',
      inputs: [
        { name: 'to', type: 'address', internalType: 'address' },
        { name: 'amount', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'name',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'pause',
      type: 'function',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'paused',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    },
    {
      name: 'renounceOwnership',
      type: 'function',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'symbol',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'totalSupply',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'uint256', internalType: 'uint256' } ],
      stateMutability: 'view'
    },
    {
      name: 'transfer',
      type: 'function',
      inputs: [
        { name: 'to', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'nonpayable'
    },
    {
      name: 'transferFrom',
      type: 'function',
      inputs: [
        { name: 'from', type: 'address', internalType: 'address' },
        { name: 'to', type: 'address', internalType: 'address' },
        { name: 'value', type: 'uint256', internalType: 'uint256' }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'nonpayable'
    },
    {
      name: 'transferOwnership',
      type: 'function',
      inputs: [
        { name: 'newOwner', type: 'address', internalType: 'address' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'unpause',
      type: 'function',
      inputs: [],
      outputs: [],
      stateMutability: 'nonpayable'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'eip1967',
  implementationAddress: '0x2C2B9C9a4a25e24B174f26114e8926a9f2128FE4',
  adminAddress: '0x6512a267aD28dFE41a5846E7aD0B2501633cB3f2',
  blockNumber: '12'
}
2025-12-25 17:47:57.154 INFO: [contract.resolver.js] >> Query.contracts 
2025-12-25 17:47:57.154 INFO: [contract.service.js] >> getContracts 
2025-12-25 17:47:57.154 INFO: [API Service] Fetching all contracts 
2025-12-25 17:47:57.154 INFO: [contract.model.js] >> getContracts 
2025-12-25 17:47:58.218 INFO: [contract.resolver.js] >> Query.contract 
2025-12-25 17:47:58.219 INFO: [contract.service.js] >> getContractByAddress 
2025-12-25 17:47:58.219 INFO: [API Service] Fetching contract data for address: 0xeec918d74c746167564401103096D45BbD494B74 
2025-12-25 17:47:58.220 INFO: [contract.model.js] >> getContractByAddress 
2025-12-25 17:47:58.227 INFO: [DB Model] Data final yang digabungkan untuk 0xeec918d74c746167564401103096D45BbD494B74: {
  query_address: '0xeec918d74c746167564401103096d45bbd494b74',
  contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  block_number: '79',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  is_verified: true,
  contract_name: 'TokenRegistry',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: '...',
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:34.067Z,
  sourceFiles: '...'
}
2025-12-25 17:47:58.228 INFO: [API Service] Raw data from model: {
  query_address: '0xeec918d74c746167564401103096d45bbd494b74',
  contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  creator_address: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creation_tx_hash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  block_number: '79',
  is_proxy: true,
  proxy_type: 'generic',
  implementation_address: null,
  admin_address: null,
  verified_contract_address: '0xeec918d74c746167564401103096D45BbD494B74',
  is_verified: true,
  contract_name: 'TokenRegistry',
  compiler_version: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    {
      name: 'LogoUpdated',
      type: 'event',
      inputs: [
        {
          name: 'tokenAddress',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'LogoUrl',
          type: 'string',
          indexed: false,
          internalType: 'string'
        },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          indexed: false,
          internalType: 'bytes32'
        },
        {
          name: 'timestamp',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'OwnershipTransferred',
      type: 'event',
      inputs: [
        {
          name: 'previousOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'newOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'getTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoData',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bytes32', internalType: 'bytes32' } ],
      stateMutability: 'view'
    },
    {
      name: 'hasLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'removeLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'setTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        { name: '_url', type: 'string', internalType: 'string' },
        {
          name: '_sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'tokenLogos',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'transferOwnership',
      type: 'function',
      inputs: [
        { name: '_newOwner', type: 'address', internalType: 'address' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'verifyLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        {
          name: '_providedHash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    }
  ],
  optimization_used: false,
  runs: 200,
  constructor_arguments: null,
  evm_version: 'paris',
  verified_at: 2025-12-25T10:33:34.067Z,
  sourceFiles: [
    {
      filePath: 'contracts/TokenRegistry.sol',
      sourceCode: 'pragma solidity ^0.8.0;\n' +
        '\n' +
        'contract TokenRegistry{\n' +
        '    address public owner;\n' +
        '\n' +
        '    struct TokenLogo{\n' +
        '        string url;\n' +
        '        bytes32 sha256Hash;\n' +
        '        uint256 timestamp;\n' +
        '    }\n' +
        '\n' +
        '    mapping(address => TokenLogo) public tokenLogos;\n' +
        '\n' +
        '    event LogoUpdated (\n' +
        '        address indexed tokenAddress,\n' +
        '        string LogoUrl,\n' +
        '        bytes32 sha256Hash,\n' +
        '        uint256 timestamp\n' +
        '    );\n' +
        '\n' +
        '    event OwnershipTransferred(\n' +
        '        address indexed previousOwner, \n' +
        '        address indexed newOwner\n' +
        '    );\n' +
        '    \n' +
        '    constructor() {\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '    \n' +
        '    // Modifier: Hanya admin yang boleh akses\n' +
        '    modifier onlyOwner() {\n' +
        '        require(msg.sender == owner, "Hanya Admin yang boleh atur logo!");\n' +
        '        _;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Set logo token dengan URL dan hash SHA256\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _url URL logo token (IPFS, HTTP, dll)\n' +
        '     * @param _sha256Hash Hash SHA256 dari file gambar (hasil dari sha256sum)\n' +
        '     * \n' +
        '     * Cara generate hash di Linux:\n' +
        '     * sha256sum logo.png\n' +
        '     * Output: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n' +
        '     */\n' +
        '    function setTokenLogo(\n' +
        '        address _tokenAddress, \n' +
        '        string memory _url, \n' +
        '        bytes32 _sha256Hash\n' +
        '    ) public onlyOwner {\n' +
        '        require(_tokenAddress != address(0), "Alamat token tidak valid!");\n' +
        '        require(bytes(_url).length > 0, "URL tidak boleh kosong!");\n' +
        '        require(_sha256Hash != bytes32(0), "Hash tidak boleh kosong!");\n' +
        '        \n' +
        '        tokenLogos[_tokenAddress] = TokenLogo({\n' +
        '            url: _url,\n' +
        '            sha256Hash: _sha256Hash,\n' +
        '            timestamp: block.timestamp\n' +
        '        });\n' +
        '        \n' +
        '        emit LogoUpdated(_tokenAddress, _url, _sha256Hash, block.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil URL logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return URL logo\n' +
        '     */\n' +
        '    function getTokenLogo(address _tokenAddress) public view returns (string memory) {\n' +
        '        return tokenLogos[_tokenAddress].url;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil hash SHA256 logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return Hash SHA256\n' +
        '     */\n' +
        '    function getTokenLogoHash(address _tokenAddress) public view returns (bytes32) {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil semua data logo token (URL, Hash, Timestamp)\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return url URL logo\n' +
        '     * @return sha256Hash Hash SHA256\n' +
        '     * @return timestamp Waktu update terakhir\n' +
        '     */\n' +
        '    function getTokenLogoData(address _tokenAddress) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (\n' +
        '            string memory url, \n' +
        '            bytes32 sha256Hash, \n' +
        '            uint256 timestamp\n' +
        '        ) \n' +
        '    {\n' +
        '        TokenLogo memory logo = tokenLogos[_tokenAddress];\n' +
        '        return (logo.url, logo.sha256Hash, logo.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Verifikasi apakah hash sesuai dengan yang tersimpan\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _providedHash Hash yang akan diverifikasi\n' +
        '     * @return true jika hash cocok\n' +
        '     */\n' +
        '    function verifyLogoHash(address _tokenAddress, bytes32 _providedHash) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (bool) \n' +
        '    {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash == _providedHash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Cek apakah token sudah punya logo\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return true jika logo sudah diset\n' +
        '     */\n' +
        '    function hasLogo(address _tokenAddress) public view returns (bool) {\n' +
        '        return bytes(tokenLogos[_tokenAddress].url).length > 0;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Transfer ownership ke address baru\n' +
        '     * @param _newOwner Address owner baru\n' +
        '     */\n' +
        '    function transferOwnership(address _newOwner) public onlyOwner {\n' +
        '        require(_newOwner != address(0), "Owner baru tidak valid!");\n' +
        '        address oldOwner = owner;\n' +
        '        owner = _newOwner;\n' +
        '        emit OwnershipTransferred(oldOwner, _newOwner);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Hapus logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     */\n' +
        '    function removeLogo(address _tokenAddress) public onlyOwner {\n' +
        '        delete tokenLogos[_tokenAddress];\n' +
        '        emit LogoUpdated(_tokenAddress, "", bytes32(0), block.timestamp);\n' +
        '    }\n' +
        '}'
    }
  ]
}
2025-12-25 17:47:58.241 INFO: [API Service] Mapped data for GraphQL: {
  address: '0xeec918d74c746167564401103096D45BbD494B74',
  creatorAddress: '0x627306090abaB3A6e1400e9345bC60c78a8BEf57',
  creationTxHash: '0x9a72867d4327f97eb537e1e01cdf9810c3ae09a6aed30ffa470916672e1b7f37',
  isVerified: true,
  sourceFiles: [
    {
      filePath: 'contracts/TokenRegistry.sol',
      sourceCode: 'pragma solidity ^0.8.0;\n' +
        '\n' +
        'contract TokenRegistry{\n' +
        '    address public owner;\n' +
        '\n' +
        '    struct TokenLogo{\n' +
        '        string url;\n' +
        '        bytes32 sha256Hash;\n' +
        '        uint256 timestamp;\n' +
        '    }\n' +
        '\n' +
        '    mapping(address => TokenLogo) public tokenLogos;\n' +
        '\n' +
        '    event LogoUpdated (\n' +
        '        address indexed tokenAddress,\n' +
        '        string LogoUrl,\n' +
        '        bytes32 sha256Hash,\n' +
        '        uint256 timestamp\n' +
        '    );\n' +
        '\n' +
        '    event OwnershipTransferred(\n' +
        '        address indexed previousOwner, \n' +
        '        address indexed newOwner\n' +
        '    );\n' +
        '    \n' +
        '    constructor() {\n' +
        '        owner = msg.sender;\n' +
        '    }\n' +
        '    \n' +
        '    // Modifier: Hanya admin yang boleh akses\n' +
        '    modifier onlyOwner() {\n' +
        '        require(msg.sender == owner, "Hanya Admin yang boleh atur logo!");\n' +
        '        _;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Set logo token dengan URL dan hash SHA256\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _url URL logo token (IPFS, HTTP, dll)\n' +
        '     * @param _sha256Hash Hash SHA256 dari file gambar (hasil dari sha256sum)\n' +
        '     * \n' +
        '     * Cara generate hash di Linux:\n' +
        '     * sha256sum logo.png\n' +
        '     * Output: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\n' +
        '     */\n' +
        '    function setTokenLogo(\n' +
        '        address _tokenAddress, \n' +
        '        string memory _url, \n' +
        '        bytes32 _sha256Hash\n' +
        '    ) public onlyOwner {\n' +
        '        require(_tokenAddress != address(0), "Alamat token tidak valid!");\n' +
        '        require(bytes(_url).length > 0, "URL tidak boleh kosong!");\n' +
        '        require(_sha256Hash != bytes32(0), "Hash tidak boleh kosong!");\n' +
        '        \n' +
        '        tokenLogos[_tokenAddress] = TokenLogo({\n' +
        '            url: _url,\n' +
        '            sha256Hash: _sha256Hash,\n' +
        '            timestamp: block.timestamp\n' +
        '        });\n' +
        '        \n' +
        '        emit LogoUpdated(_tokenAddress, _url, _sha256Hash, block.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil URL logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return URL logo\n' +
        '     */\n' +
        '    function getTokenLogo(address _tokenAddress) public view returns (string memory) {\n' +
        '        return tokenLogos[_tokenAddress].url;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil hash SHA256 logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return Hash SHA256\n' +
        '     */\n' +
        '    function getTokenLogoHash(address _tokenAddress) public view returns (bytes32) {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Ambil semua data logo token (URL, Hash, Timestamp)\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return url URL logo\n' +
        '     * @return sha256Hash Hash SHA256\n' +
        '     * @return timestamp Waktu update terakhir\n' +
        '     */\n' +
        '    function getTokenLogoData(address _tokenAddress) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (\n' +
        '            string memory url, \n' +
        '            bytes32 sha256Hash, \n' +
        '            uint256 timestamp\n' +
        '        ) \n' +
        '    {\n' +
        '        TokenLogo memory logo = tokenLogos[_tokenAddress];\n' +
        '        return (logo.url, logo.sha256Hash, logo.timestamp);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Verifikasi apakah hash sesuai dengan yang tersimpan\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @param _providedHash Hash yang akan diverifikasi\n' +
        '     * @return true jika hash cocok\n' +
        '     */\n' +
        '    function verifyLogoHash(address _tokenAddress, bytes32 _providedHash) \n' +
        '        public \n' +
        '        view \n' +
        '        returns (bool) \n' +
        '    {\n' +
        '        return tokenLogos[_tokenAddress].sha256Hash == _providedHash;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Cek apakah token sudah punya logo\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     * @return true jika logo sudah diset\n' +
        '     */\n' +
        '    function hasLogo(address _tokenAddress) public view returns (bool) {\n' +
        '        return bytes(tokenLogos[_tokenAddress].url).length > 0;\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Transfer ownership ke address baru\n' +
        '     * @param _newOwner Address owner baru\n' +
        '     */\n' +
        '    function transferOwnership(address _newOwner) public onlyOwner {\n' +
        '        require(_newOwner != address(0), "Owner baru tidak valid!");\n' +
        '        address oldOwner = owner;\n' +
        '        owner = _newOwner;\n' +
        '        emit OwnershipTransferred(oldOwner, _newOwner);\n' +
        '    }\n' +
        '    \n' +
        '    /**\n' +
        '     * @dev Hapus logo token\n' +
        '     * @param _tokenAddress Alamat kontrak token\n' +
        '     */\n' +
        '    function removeLogo(address _tokenAddress) public onlyOwner {\n' +
        '        delete tokenLogos[_tokenAddress];\n' +
        '        emit LogoUpdated(_tokenAddress, "", bytes32(0), block.timestamp);\n' +
        '    }\n' +
        '}'
    }
  ],
  contractName: 'TokenRegistry',
  compilerVersion: 'v0.8.28+commit.7893614a',
  abi: [
    { type: 'constructor', inputs: [], stateMutability: 'nonpayable' },
    {
      name: 'LogoUpdated',
      type: 'event',
      inputs: [
        {
          name: 'tokenAddress',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'LogoUrl',
          type: 'string',
          indexed: false,
          internalType: 'string'
        },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          indexed: false,
          internalType: 'bytes32'
        },
        {
          name: 'timestamp',
          type: 'uint256',
          indexed: false,
          internalType: 'uint256'
        }
      ],
      anonymous: false
    },
    {
      name: 'OwnershipTransferred',
      type: 'event',
      inputs: [
        {
          name: 'previousOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        },
        {
          name: 'newOwner',
          type: 'address',
          indexed: true,
          internalType: 'address'
        }
      ],
      anonymous: false
    },
    {
      name: 'getTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'string', internalType: 'string' } ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoData',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'getTokenLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bytes32', internalType: 'bytes32' } ],
      stateMutability: 'view'
    },
    {
      name: 'hasLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    },
    {
      name: 'owner',
      type: 'function',
      inputs: [],
      outputs: [ { name: '', type: 'address', internalType: 'address' } ],
      stateMutability: 'view'
    },
    {
      name: 'removeLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'setTokenLogo',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        { name: '_url', type: 'string', internalType: 'string' },
        {
          name: '_sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'tokenLogos',
      type: 'function',
      inputs: [ { name: '', type: 'address', internalType: 'address' } ],
      outputs: [
        { name: 'url', type: 'string', internalType: 'string' },
        {
          name: 'sha256Hash',
          type: 'bytes32',
          internalType: 'bytes32'
        },
        { name: 'timestamp', type: 'uint256', internalType: 'uint256' }
      ],
      stateMutability: 'view'
    },
    {
      name: 'transferOwnership',
      type: 'function',
      inputs: [
        { name: '_newOwner', type: 'address', internalType: 'address' }
      ],
      outputs: [],
      stateMutability: 'nonpayable'
    },
    {
      name: 'verifyLogoHash',
      type: 'function',
      inputs: [
        {
          name: '_tokenAddress',
          type: 'address',
          internalType: 'address'
        },
        {
          name: '_providedHash',
          type: 'bytes32',
          internalType: 'bytes32'
        }
      ],
      outputs: [ { name: '', type: 'bool', internalType: 'bool' } ],
      stateMutability: 'view'
    }
  ],
  optimizationUsed: false,
  runs: 200,
  constructorArguments: null,
  evmVersion: 'paris',
  isProxy: true,
  proxyType: 'generic',
  implementationAddress: null,
  adminAddress: null,
  blockNumber: '79'
}
2025-12-25 21:32:56.496 INFO: [verification.utils.js] loaded 
2025-12-25 21:33:55.581 INFO: [verification.utils.js] loaded 
